\chapter{$\mu$-演算的遗忘理论}
\label{chapter06}

{\em 本章探索$\mu$-演算中的遗忘理论。$\mu$-演算是描述转换系统性质的重要逻辑语言，其具有表达能力强的优点：$\mu$-演算是一种表达能力与S2S\footnote{无限完全二叉树下的一元二阶理论（monadic second order theory of the infinite complete binary tree），简称为S2S。}相同的逻辑语言，且LTL、CLT和CTL$^*$能表达的属性都能用$\mu$-演算来表示。
	
	已有研究表明$\mu$-演算具有均匀插值性质，这蕴涵了$\mu$-演算下的遗忘理论研究本质上与$\CTL$下的不同。
	其次，
	本章首先给出$\mu$-演算下遗忘的定义。其次，表明$\mu$-演算下的遗忘是封闭的，这是其与$\CTL$下的遗忘理论的最大的不同。最后，模型检测问题作为形式化验证的重要方法，本章给出$\mu$-演算下遗忘理论的模型检测和推理问题的复杂性结果。
	}

\section{引言}
$\mu$-演算是一种表达能力较强的逻辑语言，它能表达$\CTL$不能表示的性质，例如：Kripke结构中有一条路径，在这条路径上基数位置上的状态满足公式$\neg q \wedge \neg p$，但是偶数位置上的状态满足$q \wedge p$。这一性质不能用$\CTL$公式来表示，但是可以用$\mu$-演算公式表示如下：
$$\varphi = \nu X.(p \wedge q) \wedge \EXIST \NEXT(\neg p \wedge \neg q) \wedge \EXIST \NEXT \EXIST \NEXT X.$$

这种情形在日常生活中是很常见的，如：偏序关系$(N, \leq)$（自然数集上的小于等于关系）构成的Kripke结构，其基数节点为基数、偶数节点为偶数。
事实上，$\CTL$不能表达具有有规则的性质~\cite{DBLP:journals/iandc/Wolper83}，其主要原因是
\begin{quote}
	\emph{对于给定的原子命题$p$，任意包含$n$个“$\NEXT$”时序词的命题时序公式（ proposinal temporal formula，PTL）对于序列“$p^i(\neg p) p^w$”有相同的真值，其中$i > n$。%Given a proposition $p$, any proposinal temporal formula (PTL) $f(p)$ containing 
	%n ``next" ($\NEXT$) operators has the same truth value on all sequences of the form 
	%$p^i(\neg p) p^w$, $i > n$.
}
\end{quote}

因而得出如下结论：
\begin{quote}
	\emph{对任意的$m\geq 2$，性质“$p$在所有状态$s_i$上为真（$i = k*m$，整数$k\geq 0$）”不能用PTL中的公式来表示。
		%For any given $m\geq 2$, the property ``$p$ is true in every 
	%state $s_i$, where $i = km$ (integer $k\geq 0$)" is not expressible in PTL.
}
\end{quote}



均匀插值是一个重要的逻辑概念，其有以下含义：给定两个具有$\varphi\models\psi$关系的公式$\varphi$和$\psi$，如果存在公式$\theta$使得$\varphi\models \theta$、$\theta \models \psi$且$\Var(\theta) \subseteq \Var(\varphi) \cap \Var(\psi)$，则称公式$\theta$是$\varphi$和$\psi$的Craig插值。若$\theta$与$\psi$无关，而只与$\Var(\varphi) \cap \Var(\psi)$有关，则称$\theta$为$\varphi$关于$\Var(\varphi) \cap \Var(\psi)$的均匀插值。
均匀插值的定义~\cite{d2006modal}如下（注意：这里的$\Var(\varphi)$表示出现在$\varphi$中的原子命题和变元的集合）：                                                                                                                                                                                                                                   
\textcolor{blue}{下面两个结论放到基础知识部分。}           
\begin{definition}
	给定一个$\mu$-句子$\varphi$和集合$V\subseteq \Var(\varphi)$，$\varphi$关于$V$的均匀插值是满足下列条件的$\mu$-句子$\theta$：
	\begin{itemize}
		\item $\varphi \models \theta$；
		\item 对任意的公式$\psi$，若$\Var(\varphi) \cap \Var(\psi)\subseteq V$且$\varphi \models \psi$，则$\theta \models \psi$；
		\item $\Var(\theta) \subseteq V$。 
	\end{itemize}
\end{definition}


从直观上来说，$\varphi$关于$\Var(\varphi) \cap \Var(\psi)$的均匀插值是从$\varphi$中“移除”掉不在$\Var(\varphi) \cap \Var(\psi)$中的元素而保留其在$\Var(\varphi) \cap \Var(\psi)$上的结论得到的结果。这与遗忘有着密切的关系。

再者，在背景知识部分已经指出，任意的$\mu$-演算公式都能转换成析取$\mu$-公式，在这种形式下的公式的均匀插值是容易计算的，即：
\begin{theorem}[定理 3.6~\cite{d2006modal}]
	析取$\mu$-公式$\varphi$的均匀插值$\exists p \varphi$与$\mu$-公式$\varphi[p/\top, \neg p/ \bot]$等价，其中$\varphi[p/\top, \neg p/ \bot]$是同时将$p$及其否定$\neg p$分别用$\top$和$\bot$替换得到。
\end{theorem}



尽管上面的定义中使用的$\Var(\varphi)$表示出现在$\varphi$中的原子命题和变元的集合，但是均匀插值指的是与原子命题相关的部分，即：对任意的$\mu$-句子$\varphi$和原子命题$p$，存在一个$\mu$-句子$\widetilde{\exists} p. \varphi$使得$\widetilde{\exists} p. \varphi$是$\varphi$关于$\{p\}$的一个均匀插值。这表明在讨论均匀插值时，不考虑变元，即：不是$\varphi$关于某个变元的均匀插值。因此，在下文中$\Var(\varphi)$仍然用于表示出现在公式$\varphi$的原子命题的集合。%实际上，$\mu$-句子里的变元都是受约束的变元。

本章将要说明本文所定义的$\mu$-演算下的遗忘与文章~\cite{d2006modal}中定义的均匀插值是一对对偶概念，此时本文给出的遗忘的性质无疑也是均匀插值所具有的性质，这为$\mu$-演算的均匀插值的探索提供了另一种思路。此外，借助于均匀插值的计算方法，本文也给出了计算遗忘的方法。这形成了遗忘和均匀插值之间相辅相成的作用。

本章的组织结构如下。首先，给出$\mu$-演算下遗忘的定义；然后，探讨遗忘的一般性质，并给出其与均匀插值的关系；最后给出与遗忘相关问题的复杂性。

\section{$\mu$-演算遗忘}\label{sec:chapter06-system-model}
与$\CTL$情形下的遗忘相似，这里先给出$V$互模拟的定义。不失一般性地，令$\Hm_i = (S_i, R_i, L_i, r_i)$，$i$为自然数集$\mathbb{N}$中的元素。
\begin{definition}[$V$-互模拟]\label{def:VB}
	给定原子命题集合$V \subseteq \Ha$和两个Kripke结构$\Hm_1$和 $\Hm_2$。若下面几个条件满足，则称$\Hb\subseteq S_1 \times S_2$是$\Hm_1$和 $\Hm_2$的$V$-互模拟关系：
	\begin{itemize}
		\item $r_1 \Hb r_2$，
		\item 对任意的$s\in S_1$和 $t\in S_2$，若$s \Hb t$则对任意的$p \in \Ha- V$有 $p \in L_1(s)$当且仅当 $p \in L_2(t)$，
		\item $(s, s')\in R_1$和 $s \Hb t$蕴涵存在一个 $t'$使得 $s' \Hb t'$和 $(t, t')\in R_2$，且
		\item 若 $s \Hb t$且 $(t, t')\in R_2$，则存在一个$s'$使得 $(s, s')\in R_1$和 $t' \Hb s'$。
	\end{itemize}
\end{definition}

一方面，与$\CTL$下的$V$-互模拟不同的是，这里要求$r_1 \Hb r_2$（即：$(r_1,r_2)\in \Hb$）。
如果$\Hm_1$和 $\Hm_2$之间存在一个$V$-互模拟关系${\cal B}$则称这两个Kripke结构$\Hm_1$和 $\Hm_2$及由这两个Kripke结构构成的结构$(\Hm_1,r_1)$和$(\Hm_2,r_2)$是$V$-互模拟的，分别记为$\Hm_1 \lrto_V \Hm_2$和$(\Hm_1,$ $r_1) \lrto_V (\Hm_2,r_2)$。
显然，Kripke结构之间的$V$-互模拟与结构之间的$V$-互模拟是等价的：$\Hm_1 \lrto_V \Hm_2$当且仅当$(\Hm_1,r_1) \lrto_V (\Hm_2,r_2)$， 因此在下文中只讨论Kripke结构之间$V$-互模拟的性质，而结构之间的互模拟的性质与之相同。不难看出初始结构之间的$V$-互模拟是结构之间的$V$-互模拟的一个特例。


另一方面，$V$-互模拟与${\cal L}$-互模拟\footnote{${\cal L}$-互模拟是一种将定义\ref{def:VB}中的$V$替换为${\cal L}$的二元关系。}~\cite{d1996uniform}类似，不同的是$V$-互模拟只考虑原子命题，且当${\cal L}$为原子命题集合时是${\cal L}$-互模拟补命题（这里默认除了原子命题之外的符号都是相同的，因此只考虑原子命题）。
此外，已有结果表明${\cal L}$-句子（符号只出现在${\cal L}$中的$\mu$-句子）关于${\cal L}$-互模拟是{\em 不变的}，即若$\Hm$和 $\Hm'$是${\cal L}$-互模拟的，则对于${\cal L}$-句子$\varphi$有$\Hm \models \varphi$当且仅当$\Hm' \models \varphi$~\cite{d1996uniform,bradfield2018mu}。
因此，若$\IR(\varphi, V)$且$\Hm \lrto_V \Hm'$，则$\Hm \models \varphi$当且仅当$\Hm' \models \varphi$。
本文称这一性质为$V$-不变性。
%值得注意的是这里的结构之间的$V$-互模拟是$\CTL$
%In this case, $\Hm_1$ and $\Hm_2$ are bisimilar on $V$.
\begin{example}
	\label{exmp:c06:bisim}
	如图\ref{chapter06:fig:bisim}中的两个Kripke结构$\Hm=(S,R,L,r)$和 $\Hm'=(S',R',L',r')$，其中:
	\begin{itemize}
		\item $S=\{s_0,s_1,s_2\}$，$S'=\{t_0,t_1\}$，$r=s_0$，$r'=t_0$；
		\item $R=\{(s_0,s_1),(s_1,s_0),(s_0,s_2),(s_2,s_0)\}$，$R'=\{t_0,t_1\}$；
		\item $L(s_0)=\{ch,j\}$，$L(s_1)=\{ch\}$，$L(s_2)=\emptyset$，$L'(t_0)=\{j\}$，$L'(t_1)=\emptyset$。
	\end{itemize}
	由于$\Hm$和 $\Hm'$之间存在一个二元$\{ch\}$-互模拟$\Hb=\{(s_0, t_0), (s_1, t_1), (s_2, t_1)\}$，所以 $\Hm \lrto_{\{ch\}} \Hm'$。%，所以$\Hm\lrto \Hm'$。
	
	
	
	% 	\begin{center}\label{fig:bisim}
	% 		\includegraphics[width=5cm,height=3cm]{chBisimilar.png}\\
	% 		%\vspace{2mm}
	% 		\parbox[c]{7cm}{\textbf{Fig.1~}  Two $\{ch\}$-bisimilar Kripke structures}%\vspace*{.2mm}
	% 	\end{center}
	
	\begin{figure}[h]%
		\centering
		\includegraphics[width=4.5cm,height=2.5cm]{chapter06/chvB1.png}
		\caption{两个 $\{ch\}$-互模拟的Kripke结构示意图}\label{chapter06:fig:bisim}
		
		% $s_0$ is labeled by $\{ch, j\}$, $t_0$ is labeled by $\{j\}$, and $s_1$, $s_2$, and $t_1$ are labeled by $\emptyset$.}\label{fig:bisim}
	\end{figure}
	
\end{example}

$\mu$-句子互模拟是不变的，$\mu$-公式则不是~\cite{janin1996expressive}。这里定义一种对$\mu$-公式是不变的互模拟。
\begin{definition}[Var-$V$-互模拟]
	\label{def:varVb}
	给定原子命题集合$V$、赋值$(\Hm, v)$和$(\Hm',v')$。$(\Hm, v)$和$(\Hm',v')$之间的一个Var-$V$-互模拟关系$\Hb$是$\Hm$和$\Hm'$之间一个$V$-互模拟关系，且满足：
	若 $(s,s') \in {\cal B}$，则对任意$X\in {\cal V}$， $s\in v(X)$ 当且仅当 $s'\in v'(X)$。
\end{definition}

若$(\Hm, v)$和$(\Hm',v')$之间存在一个Var-$V$-互模拟关系$\Hb$，则称$(\Hm, v)$和$(\Hm',v')$是Var-$V$-互模拟的，记为$(\Hm, v)\lrto_V(\Hm',v')$。
对$\Hm$中的状态集$S_1\subseteq S$，用$\Hb(S_1)$表示通过$\Hb$从$S_1$映射得来的状态集，即： $\Hb(S_1) =\{s' \mid (s, s')\in \Hb,\ s \in S_1\}$。

\begin{example}[例~\ref{exmp:c06:bisim}的延续]
	令 $\Hm$和 $\Hm'$为图~\ref{chapter06:fig:bisim}中的Kripke结构，$v: {\cal V} \rto 2^S$和$v': {\cal V} \rto 2^{S'}$为将${\cal V}$中的变元分别赋值到$\Hm$和$\Hm'$的状态集上的赋值函数。可以检查下面的结论成立：
		\begin{itemize}
			\item 若对任意的$X\in\cal V$，$v(X)= \{s_0, s_1, s_2\}$ 且$v'(X)=\{t_0, t_1\}$，则$({\cal M},v)\lrto_{\{ch\}} ({\cal M}',v')$；
			
			\item 若对任意的$X\in{\cal V}-\{X_1\}$，$v(X_1)= \{s_0\}$、$v'(X_1)=\{t_1\}$、$v(X)= \{s_0, s_1, s_2\}$且$v'(X)=\{t_0, t_1\}$，则$({\cal M},v)\not\lrto_{\{ch\}} ({\cal M}',v')$；这是因为$(s_0,t_0)\in {\cal B}$且 $s_0\in v(X_1)$，但是$t_0\notin v'(X_1)$。
		\end{itemize}
\end{example}

显然，对任意的集$V\subseteq \Ha$，每个Var-$V$-互模拟与一个$V$-互模拟对应，即：$({\cal M},v)\lrto_V({\cal M}',v')$ 蕴涵${\cal M}\lrto_V{\cal M}'$。
另一方面，Kripke结构$\Hm$和$\Hm'$之间的每个$V$-互模拟可被扩展为$(\Hm, v)$和$(\Hm',v')$一个Var-$V$-互模拟，其中对任意的$X\in {\cal V}$，$v(X) = S$且$v'(X) = S'$，$S$和$S'$分别为$\Hm$和$\Hm'$中的状态集合。

可以容易证明$\lrto_V$有如下性质。

\begin{proposition} \label{pro:EqUnion}
	令$V, V_1 \subseteq \Ha$为原子命题的集合，$(\Hm_1,v_1)$、 $(\Hm_2,v_2)$和$(\Hm_3,v_3)$为赋值，则：
	\begin{itemize} 
		\item[(i)] $\lrto_V$是 赋值之间的等价关系；
		\item[(ii)] 若$(\Hm_1, v_1) \lrto_V (\Hm_2,v_2)$ 和$V \subseteq V_1$，则$(\Hm_1, v_1) \lrto_{V_1} (\Hm_2,v_2)$；
		\item[(iii)] 若 $(\Hm_1, v_1)  \lrto_V (\Hm_2,v_2)$且 $(\Hm_2,v_2) \lrto_{V_1} (\Hm_3,v_3)$，则 $(\Hm_1, v_1) \lrto_{V \cup V_1} (\Hm_3,v_3)$。
	\end{itemize}
	
\end{proposition}
\begin{proof}
	(i) 这里从自反性、对称性和传递性来证明该关系是一个等价关系。
	
	(1) $\lrto_V$是自反的。容易检查对任意的赋值$(\Hm,v)$都有$(\Hm,v)\lrto_V (\Hm,v)$。
	
	(2) $\lrto_V$是对称的。 这里证明对任意的$(\Hm_1, v_1)$ 和$(\Hm_2,v_2)$，若$(\Hm_1, v_1) \lrto_V (\Hm_2,v_2)$，则$(\Hm_2, v_2) \lrto_V (\Hm_1, v_1)$。
	假设 $(\Hm_1, v_1)$和$(\Hm_2,v_2)$之间的Var-$V$-互模拟关系$\Hb$，构造如下二元关系：$\Hb_1=\{(s,t) \mid (t, s)\in \Hb\}$。现在从下面几点证明 $\Hb_1$ 是$\Hm_2$和 $\Hm_1$之间的一个$V$-互模拟关系：
	\begin{itemize}
		\item 由于$r_1 \Hb r_2$，所以$r_2 \Hb_1 r_1$，
		\item 对任意的$s\in S_1$和 $t\in S_2$，若 $t \Hb_1 s$，则 $s\Hb t$，因此对于任意的$p \in \Ha - V$，$p \in L_1(s)$当且仅当 $p \in L_2(t)$，且
		\item 因为$\Hb$是$\Hm_1$和 $\Hm_2$之间的$V$-互模拟关系，所以$V$-互模拟的第三和第四个点很容易能够证明。
	\end{itemize}
	
	此外，若$(s,t) \in \Hb$，则对任意的$X\in {\cal V}$，$s \in v_1(X)$ 当且仅当$t \in v_2(X)$。因此，若$(t,s) \in \Hb_1$， 则对任意的$X\in {\cal V}$，$t \in v_2(X)$ 当且仅当$s\in v_1(X)$。所以，$(\Hm_2, v_2) \lrto_V (\Hm_1, v_1)$。
	
	
	(3) $\lrto_V$是传递的。这里证明若$(\Hm_1,v_1) \lrto_V (\Hm_2,v_2)$ 和$(\Hm_2,v_2) \lrto_V (\Hm_3,v_3)$，则 $(\Hm_1,$ $v_1)$ $\lrto_V$ $(\Hm_3,v_3)$。假定 $(\Hm_1,v_1)$和$(\Hm_2,v_2)$之间的Var-$V$-互模拟关系为$\Hb_1$，$(\Hm_2,v_2)$和$(\Hm_3,$ $v_3)$之间的Var-$V$-互模拟关系为$\Hb_2$，构造如下二元关系：
	$\Hb=\{(s, z) \mid (s,t) \in \Hb_1\ \mbox{和}\ (t, z)\in \Hb_2 \hbox{其中} s\in S_1,  t\in S_2, \hbox{其} z \in S_3\}$。
	可以类似(2)证明$\Hb$为$\Hm_1$ 和$\Hm_3$的一个$V$-互模拟关系，即：$\Hm_1 \lrto_V \Hm_3$。
	
	
此外，若$(s,z) \in \Hb$，则存在$t \in S_2$使得$(s, t) \in \Hb_1$ 和$(t,z)\in \Hb_2$，所以，对任意的$X\in {\cal V}$，$s \in v_1(X)$ 当且仅当$t \in v_2(X)$ 当且仅当$z\in \Hb$。因此，$(\Hm_1, v_1) \lrto_V (\Hm_3, v_3)$。
	
	
	(ii) 假设$\Hb_{V}$是$(\Hm_1,v_1)$ 和$(\Hm_2,v_2)$之间的一个Var-$V$-互模拟关系。这里证明$\Hb_{V}$是$(\Hm_1,$ $v_1)$ 和$(\Hm_2,v_2)$之间的一个Var-$V_1$-互模拟关系。
	显然：
	\begin{itemize}
		\item $(r_1, r_2) \in \Hb_{V}$，
		\item 对任意的$w_1\in S_1$和$w_2\in S_2$，若$(w_1, w_2) \in \Hb_{V}$，因为$V \subseteq V_1$且对任意的$p \in \Ha - V$，$p\in L_1(w_1)$ 当且仅当$p\in L_2(w_2)$，所以，对任意的$p \in \Ha - V_1$，
		$p\in L_1(w_1)$ 当且仅当$p\in L_2(w_2)$，
		%$L_1(w_1) - V_1 = L_2(w_2) -V_1$ since $L_1(w_1) - V = L_2(w_2) -V$ and $V \subseteq V_1$,
		\item %$\forall r_1 \in S_1$, 
		若 $(w_1,r_1) \in R_1$ 和$(w_1, w_2)\in \Hb_V$，因为$\Hb_{V}$ 是$\Hm_1$ 和$\Hm_2$之间的一个$V$-互模拟关系，所以，$\exists r_2\in S_2$使得$(w_2,r_2)\in R_2$ 和$(r_1,r_2) \in \Hb_{V}$，
		\item %$\forall r_2 \in S_2$, 
		若$(w_2,r_2) \in R_2$ 和$(w_1, w_2)\in \Hb_V$，因为$\Hb_{V}$ 是$\Hm_1$ 和$\Hm_2$之间的一个$V$-互模拟关系，所以，$\exists r_1\in S_1$ 使得$(w_1,r_1)\in R_1$ 和$(r_1,r_2) \in \Hb_{V}$。
\end{itemize}
因此，$\Hb_V$$\Hm_1$ 和$\Hm_2$之间的一个$V_1$-互模拟关系。

此外，若$(s,t) \in \Hb_V$，则对任意的$X\in {\cal V}$，$s \in v_1(X)$ 当且仅当$t \in v_2(X)$。因此，$(\Hm_1,v_1) \lrto_{V_1} (\Hm_2,v_2)$。
	
	(iii) 由(ii)可知，$(\Hm_1,v_1) \lrto_V (\Hm_2,v_2)$ 蕴涵$(\Hm_1,v_1) \lrto_{V \cup V_1} (\Hm_2,v_2)$，由(i)的传递性可知$(\Hm_1,v_1) \lrto_{V\cup V_1} (\Hm_3,v_3)$。
\end{proof}

不难看出，命题~\ref{pro:EqUnion}对于Kripke结构之间的$\lrto_V$关系也是成立的。
直观地说，(i)表示$\lrto_V$是赋值之间的自反、对称和传递关系。
(ii)指明若两个赋值是Var-$V$-互模拟的，则对于$V$的任意一个超级$V_1$，这两个赋值都是Var-$V_1$-互模拟的。
(iii)表示如果一个Kripke结构和其他两个Kripke结构互相$V$和$V_1$互模拟，则这两个Kripke结构$V\cup V_1$-互模拟。这跟$\CTL$情形下的互模拟类似，正如下文将要说到的那样，这一性质有助于证明$\mu$-演算下遗忘的分解属性。

对于含有自由变元$Y\in {\cal V}$的$\mu$-公式$\varphi(Y)$，记$\varphi_{{\cal S}(Y)}$为将$\varphi(Y)$中所有$Y$的出现用一个新的原子命题$p_y$替换得到的公式。
此时，给定赋值$(\Hm,v)$，$\Hm=(S,r,R,L)$在自由变元$Y$上关于$\varphi(Y)$和$v$的{\em 扩展}为$\Hm_{{\cal S}(Y)} = (S, r, R, L_y)$，其中对任意的$s\in S$：
\[L_y(s) =
\left\{
\begin{array}{ll}
	L(s)\cap \Var(\varphi(Y)), \ \ \qquad \qquad \quad \hbox{若$s\not \in v(Y)$；} \\
	(L(s) \cap \Var(\varphi(Y)))\cup \{p_y\}, \ \ \ \quad \ \ \hbox{否则。}
\end{array}
\right.
\]
从直观上来说，公式$\varphi(Y)$中的自由变元在给定赋值$(\Hm,v)$下可以看作一个原子命题，该原子命题在状态集$v(Y)$为真，在其他状态上为假。

类似地，对于公式$\varphi(\tau)$（$\tau$为$\varphi(\tau)$中自由变元的集合），记$\varphi_{{\cal S}(\tau)}$为将$\varphi(\tau)$中出现在$\tau$中的每个自由变元迭代地用新的原子命题替换得到的公式，即：
\begin{align*}
	& \varphi_{\emptyset} = \varphi(\emptyset) =\varphi\\
	& \varphi_{{\cal S}(\{Y\})} = \varphi_{{\cal S}(Y)}, \\
	& \varphi_{{\cal S}(\{Y_1, Y_2, \dots, Y_n\})}= (\varphi_{{\cal S}(Y_1)})_{{\cal S}(\{Y_2, \dots, Y_n\})}.
\end{align*}
$\Hm=(S,r,R,L)$在自由变元集合$\tau$上关于$\varphi(\tau)$和赋值$v$的扩展为$\Hm_{{\cal S}(\tau)}= (S, r, R, L_{\tau})$使得
\begin{align*}
	& \Hm_{\emptyset} = \Hm,\\
	& \Hm_{{\cal S}(\{Y\})} = \Hm_{{\cal S}(Y)},\\
	& \Hm_{{\cal S}(\tau)}=\Hm_{{\cal S}(Y_1){\cal S}(\{Y_2,\dots, Y_n\})},
\end{align*}
且对任意$s\in S$，
\begin{align*}
	& L_{\emptyset}(s) = L(s),\\
	& L_{\{Y\}}(s) = L_y(s),\\
	& L_{\tau}(s) = L_{y_1\{Y_2, \dots, Y_n\}}(s) \\
	&\qquad \ =
	\left\{
	\begin{array}{ll}
		L_{\{Y_2, \dots, Y_n\}}(s)\cap \Var(\varphi_{{\cal S}\{Y_2, \dots, Y_n\}}), \ \ \qquad \qquad \quad \hbox{若$s\not \in v(Y_1)$;} \\
		(L_{\{Y_2, \dots, Y_n\}}(s) \cap \Var(\varphi_{{\cal S}\{Y_2, \dots, Y_n\}})) \cup \{p_{y_1}\}, \ \ \quad  \ \ \hbox{否则。}
	\end{array}
	\right.
\end{align*}

\begin{example}[例~\ref{exmp:c06:bisim}的延续]
	\label{exp:freshp}
	令$\varphi(\{Y,Z\}) = \mu X. ch \wedge j \wedge Z\wedge \EXIST\NEXT Y \wedge \EXIST\NEXT \EXIST\NEXT X$，$\Hm = (S,s_0, R, L)$ 为例~\ref{exmp:c06:bisim}，则
	$$\varphi_{{\cal S}(Y)}(Z) = \mu X. ch \wedge j \wedge Z \wedge \EXIST\NEXT p_y \wedge \EXIST\NEXT \EXIST\NEXT X\hbox{，}$$
	$$\varphi_{{\cal S}(\{Y,Z\})} = \mu X. ch \wedge j \wedge p_z \wedge \EXIST\NEXT p_y \wedge \EXIST\NEXT \EXIST\NEXT X\hbox{。}$$
	
	令$v$为将${\cal V}$中变元映射到$\Hm$状态集上的赋值函数，且$v(Y) = \{s_1,s_2\}$、$v(Z) = \{s_0\}$，则：
	%Let $v$ be the valuation of variables in ${\cal V}$ to the states of $\Hm$ with $v(Y) = \{s_1,s_2\}$ and $v(Z) = \{s_0\}$, then:
	\begin{itemize}
		\item $\Hm$在$Y$上关于$\varphi(\{Y,Z\})$ 和$v$的扩展为：$\Hm_{{\cal S}(Y)} = (S,s_0, R, L_y)$，其中 $L_y(s_0) = \{j,ch\}$、 $L_y(s_1)=\{ch, p_y\}$且 $L_y(s_2)=\{p_y\}$；
		\item $\Hm$ 在$\{Y,Z\}$上关于$\varphi(\{Y,Z\})$和$v$的扩展为：$\Hm_{{\cal S}(\{Y,Z\})} = (S,s_0, R, L_{yz})$，其中$L_{yz}(s_0) = \{j,ch,p_z\}$、 $L_{yz}(s_1)=\{ch, p_y\}$且$L_{yz}(s_2)=\{p_y\}$。
	\end{itemize}
\end{example}

下面的性质对证明Var-$V$-互模拟对于$\mu$-公式是不变的是至关重要的。
\begin{proposition}
	\label{pro:statequ}
	令$\varphi(Y)$为含有自由变元$Y$的$\mu$-公式（$Y\in {\cal V}$），$(\Hm,v)$为赋值，则$$\left \|\varphi(Y) \right\|_v^{\Hm} = \left \|\varphi_{{\cal S}(Y)} \right\|_v^{\Hm_{{\cal S}(Y)}}\hbox{。}$$
\end{proposition}
\begin{proof}
	对公式的结构做归纳来证明这一结论。
	
	\textbf{基始.} (1) $\varphi(Y) = X$，其中$X \not = Y$。
	
	$\left \|X \right\|_v^{\Hm} = v(X)$，
	
	$\left \|X_{{\cal S}(Y)} \right\|_v^{\Hm_{{\cal S}(Y)}} = \left \|X \right\|_v^{\Hm_{{\cal S}(Y)}}= v(X)$。
	
	
	(2) $\varphi(Y) = Y$.
	%$Y_{{\cal S}(Y)} = p_y$, then 
	\begin{align*}
		\left \|Y \right\|_v^{\Hm} & = v(Y)\\
		\left \|Y_{{\cal S}(Y)} \right\|_v^{\Hm_{{\cal S}(Y)}} & = \left \|p_y \right\|_v^{\Hm_{{\cal S}(Y)}} \\
		& = \{s \mid p_y \in L_y(s)\} \\
		& = \{s \mid s \in v(Y)\}\\
		& = v(Y)
	\end{align*}
	
	(3) $\varphi(Y) = p$，其中$p\in \Ha$。
	\begin{align*}
		\left \|p \right\|_v^{\Hm} &  = \{s \mid p \in L(s)\},\\
		\left \|p_{{\cal S}(Y)} \right\|_v^{\Hm_{{\cal S}(Y)}}  & = \left \|p \right\|_v^{\Hm_{{\cal S}(Y)}} \\
		& = \{s \mid p \in L_y(s)\}\\
		& = \{s \mid p \in L(s)\}.
	\end{align*}
	
	\textbf{归纳步.}
	
	(1) $\varphi(Y) = \neg p$.
	\begin{align*}
		\left \|\neg p \right\|_v^{\Hm} & = S- \left \|p \right\|_v^{\Hm}\\
		\left \|\neg p_{{\cal S}(Y)} \right\|_v^{\Hm_{{\cal S}(Y)}} & = \left \|\neg p \right\|_v^{\Hm_{{\cal S}(Y)}} \\
		&  = S - \left \|p \right\|_v^{\Hm_{{\cal S}(Y)}}\\
		& = S - \left \|p \right\|_v^{\Hm} \qquad \qquad \qquad \qquad \qquad \hbox{  (归纳假设)}
	\end{align*}
	
	%Therefore, we have $\left \|\neg p \right\|_v^{\Hm} = \left \|\neg p_{{\cal S}(Y)} \right\|_v^{\Hm_{\cal S}(Y)}$  by induction hypothesis.
	
	(2) $\varphi(Y) = \varphi_1(Y) \vee \varphi_2(Y)$.
	\begin{align*}
		\left \| \varphi \right\|_v^{\Hm}& = \left \|\varphi_1(Y) \right\|_v^{\Hm} \cup \left \| \varphi_2(Y) \right\|_v^{\Hm}\\
		\left \| \varphi_{{\cal S}(Y)} \right\|_v^{\Hm_{{\cal S}(Y)}}& = \left \|\varphi_{1{\cal S}(Y)} \right\|_v^{\Hm_{{\cal S}(Y)}} \cup \left \| \varphi_{2{\cal S}(Y)} \right\|_v^{\Hm_{{\cal S}(Y)}}\\
		& = \left \|\varphi_1(Y) \right\|_v^{\Hm} \cup \left \| \varphi_2(Y) \right\|_v^{\Hm} \qquad  \qquad \qquad \qquad \hbox{  (归纳假设)}
	\end{align*}
	
	%We have $\left \|\varphi_1 \right\|_v^{\Hm}= \left \|\varphi_{1{\cal S}(Y)} \right\|_v^{\Hm_{\cal S}(Y)}$ and $\left \| \varphi_2 \right\|_v^{\Hm} =  \left \| \varphi_{2{\cal S}(Y)} \right\|_v^{\Hm_{\cal S}(Y)}$ by induction hypothesis. Therefore, $\left \| \varphi \right\|_v^{\Hm}= \left \| \varphi_{{\cal S}(Y)} \right\|_v^{\Hm_{\cal S}(Y)}$.
	
	$\varphi(Y) = \varphi_1(Y) \wedge \varphi_2(Y)$的情形可以类似地证明。
	
	(3) $\varphi(Y) = \ALL \NEXT \varphi_1(Y)$.
	\begin{align*}
		\left \|\varphi \right(Y)\|_v^{\Hm} & = \{s \mid \forall s'. (s, s') \in R \Rto s' \in \left \|\varphi_1(Y) \right\|_v^{\Hm}\}\\
		\left \|\varphi_{{\cal S}(Y)} \right\|_v^{\Hm_{{\cal S}(Y)}} & = \{s \mid \forall s'. (s, s') \in R \Rto s' \in \left \|\varphi_{1{\cal S}(Y)} \right\|_v^{\Hm_{{\cal S}(Y)}}\}\\
		& = \{s \mid \forall s'. (s, s') \in R \Rto s' \in \left \|\varphi_1(Y) \right\|_v^{\Hm}\} \qquad \qquad \hbox{  (归纳假设)}
	\end{align*}
	
	(4) $\varphi(Y)  = \mu X. \varphi_1(Y)$.
	
	$\left \|\varphi(Y) \right\|_v^{\Hm}= \bigcap \{S_1 \subseteq S \mid \left \|\varphi_1(Y) \right\|_{v[X:=S_1]}^{\Hm} \subseteq S_1\}$.
	
	\begin{align*}
		\left \|\varphi(Y)_{{\cal S}(Y)} \right\|_v^{\Hm_{{\cal S}(Y)}} & = \left \|\mu X. \varphi_{1}(Y)_{{\cal S}(Y)} \right\|_v^{\Hm_{{\cal S}(Y)}}\\
		& = \bigcap \{S_1 \subseteq S \mid \left \|\varphi_{1{\cal S}(Y)} \right\|_{v[X:=S_1]}^{\Hm_{{\cal S}(Y)}} \subseteq S_1\}\\
		& = \bigcap \{S_1 \subseteq S \mid \left \|\varphi_1(Y) \right\|_{v[X:=S_1]}^{\Hm} \subseteq S_1\} \qquad\qquad \hbox{  (归纳假设)}
	\end{align*}
\end{proof}

命题~\ref{pro:statequ}表明$(\Hm, v) \models \varphi(Y)$ 当且仅当$(\Hm_{{\cal S}(Y)}, v) \models \varphi_{{\cal S}(Y)}$。 % Moreover,
\begin{example}
	[例~\ref{exp:freshp}的延续] 
	令$\varphi = \EXIST\NEXT Y \wedge \nu X. (ch \wedge j \wedge \EXIST\NEXT \EXIST \NEXT X)$，则 
	\begin{align*}
		&\varphi_{{\cal S}(Y)} = \EXIST\NEXT p_y \wedge \nu X. (ch \wedge j \wedge \EXIST\NEXT \EXIST \NEXT X),\\
		&\left\|\varphi\right\|_v^{\Hm} = \{s_0\},\\
		&\left\|\varphi_{{\cal S}(Y)}\right\|_v^{\Hm_{{\cal S}(Y)}} = \{s_0\}.
	\end{align*}
\end{example}

\begin{lemma}
	\label{lem:vbextension}
	令$\tau \subseteq {\cal V}$为变元集合，$\varphi(\tau)$为含有$\tau$中自由变元的公式，$V\subseteq \Ha$为原子命题集合。若$(\Hm, v) \lrto_V (\Hm',v')$，则 $\Hm_{{\cal S}(\tau)} \lrto_V \Hm'_{{\cal S}(\tau)}$。
\end{lemma}
\begin{proof}
	令$\Hb$为$(\Hm, v)$ 和$(\Hm',v')$之间的Var-$V$-互模拟关系，这里证明$\Hb$是$\Hm_{{\cal S}(\tau)}$ 和$\Hm'_{{\cal S}(\tau)}$之间的$V$-互模拟关系。
	\begin{itemize}
		\item $(r,r')\in \Hb$,
		\item 对任意的$s\in S$ 和$t\in S'$，若$(s,t)\in \Hb$，因为$\Hm \lrto_V \Hm'$且对任意的$Y\in \tau$，$s\in v(Y)$ 当且仅当$t \in v'(Y)$，这意味着$p_y\in L_{\tau}(s)$ 当且仅当$p_y \in  L_{\tau}'(t)$；所以，对任意的 $p\in \Ha-V$，$p\in L_{\tau}(s)$ 当且仅当$p\in L_{\tau}'(t)$， %Moreover, for each $p \in $
		\item 因为$\Hm \lrto_V \Hm'$，所以$V$-互模拟的第三和四点容易证明。
	\end{itemize}
\end{proof}

基于此，可以证明Var-$V$-互模拟关于$\mu$-公式是不变的。
\begin{proposition}[Var-$V$-invariant]
	\label{pro:variB}
	令$\varphi(\tau)$为$\mu$-公式，出现在其中所有的自由变元构成集合$\tau \subseteq {\cal V}$，$V$为原子命题的集合。若$(\Hm, v) \lrto_V (\Hm',v')$ 且$\IR(\varphi(\tau), V)$，则$(\Hm,v) \models \varphi(\tau)$ 当且仅当$(\Hm',v') \models \varphi(\tau)$。
\end{proposition}
\begin{proof}
	不失一般性地，令$\Var(\varphi(\tau))\cap V = \emptyset$、$\tau=\{Y_1, \dots, Y_n\}$、$p_{\tau} = \{p_{y_1}, \dots, p_{y_n}\} \cap (V \cup \Var(\varphi)) = \emptyset$且$\varphi_{{\cal S}(\tau)}$ 为将$\varphi(\tau)$中的每个自由变元$Y_i\in \tau$用新的原子命题$p_{y_i} \in p_{\tau}$替换得到的公式，其中$i = 1, \dots, n$。不难看出 $\varphi_{{\cal S}(\tau)}$为一个$V$-无关的$\mu$-句子。
	\begin{align*}
		\left\| \varphi(\{Y_1, \dots, Y_n\})\right\|_v^{\Hm} & = \left\| \varphi_{{\cal S}(Y_1)({\cal S}(\{Y_2, \dots, Y_n\}))}\right\|_v^{\Hm_{{\cal S}(Y_1){\cal S}(\{Y_2,\dots, Y_n\})}}\\
		& = \left\| \varphi_{{\cal S}(Y_1){\cal S}(Y_2)({\cal S}(\{Y_3, \dots, Y_n\}))}\right\|_v^{\Hm_{{\cal S}(Y_1){\cal S}(Y_2){\cal S}(\{Y_3,\dots, Y_n\})}}\\
		& \dots\\
		& = \left\| \varphi_{{\cal S}(Y_1) \dots {\cal S}(Y_n)}\right\|_v^{\Hm_{{\cal S}(Y_1)\dots {\cal S}(Y_n)}}\\
		& = \left\| \varphi_{{\cal S}(\tau)}\right\|_v^{\Hm_{{\cal S}(\tau)}}\hbox{。}
	\end{align*}
	因此，$(\Hm, v) \models \varphi(\tau)$ 当且仅当$(\Hm_{{\cal S}(\tau)}, v) \models \varphi_{{\cal S}(\tau)}$。
	
	由引理\ref{lem:vbextension}可知$\Hm_{{\cal S}(\tau)} \lrto_V \Hm'_{{\cal S}(\tau)}$。因此，对任意$V$-无关的$\mu$-句子$\psi$，$\Hm_{{\cal S}(\tau)}\models \psi$ 当且仅当$\Hm'_{{\cal S}(\tau)}\models \psi$。
	
	所以，$(\Hm,v) \models \varphi(\tau)$ 当且仅当$(\Hm',v') \models \varphi(\tau)$。
\end{proof}

命题~\ref{pro:variB}表明，若两个赋值是Var-$V$-互模拟的，则这两个赋值同时满足（或不满足）同一个与$V$无关的公式。
例如，$(\Hm_i,v_i)$ $i=1,2$为两个赋值，$\varphi =X$，$V=\{p\}$；若$(\Hm_1, v_1) \lrto_V (\Hm_2,v_2)$，则可以证明$(\Hm_1,v_1) \models \varphi$ 当且仅当$(\Hm_2,v_2) \models \varphi$。

此时，$\mu$-演算下的遗忘如下定义：
\begin{definition}[$\mu$-演算下的遗忘]\label{chapter06:def:V:forgetting}
	令$V\subseteq\cal A$和 $\varphi$为$\mu$-公式。若$\Var(\psi) \cap V=\emptyset$且下面等式成立，则称
	 $\psi$是从$\varphi$中遗忘掉$V$后得到的结果：
	\begin{equation*}
		\Mod(\psi)=\{(\Hm,v) \mid \exists (\Hm',v') \in\Mod(\varphi)\ \hbox{且} (\Hm',v') \lrto_V (\Hm,v)\}\hbox{。}
	\end{equation*}
\end{definition}

显然，当讨论的公式为$\mu$-句子的时候，定义~\ref{chapter06:def:V:forgetting}中的模型变成$\Hm$和$\Hm'$，即去掉赋值函数$v$和$v'$。

定义~\ref{chapter06:def:V:forgetting}表明如果 $\psi$和 $\psi'$都是从$\varphi$中遗忘掉 $V$中的原子命题得到的结果，则
$\Mod(\psi)$ $=\Mod(\psi')$，也就是说遗忘的结果之间是语义等价的（即有相同的模型）。此时，将遗忘的结果记为 $\Muforget(\varphi, V)$，除非另有说明，否则$\Muforget(\varphi, V)$表示从$\varphi$中遗忘$V$的结果是$\mu$-公式。
%, i.e., $\psi$ and $\psi'$ have the same models. 




\section{$\mu$-演算遗忘的性质}
这部分展示$\mu$-演算下遗忘的语义属性。特别地，这里将证明上述$\mu$-演算下的遗忘的定义与遗忘的那几条规则具有“当且仅当的关系”，且从任意$\mu$-句子中遗忘掉任意原子命题的集合的结果总是一个$\mu$-句子。此外，也研究了遗忘算子的代数属性，包括分解性（decomposition）、切片性（slice）和同质性（homogeneity）。

\begin{theorem} \label{thm:exist}
	给定原子命题 $q \in \cal A$和$\mu$-句子 $\varphi$，则存在一个$\mu$-句子 $\psi$使得 $\Var(\psi)\cap \{q\} = \emptyset$且 $\psi \equiv \Muforget(\varphi, \{q\})$。
\end{theorem}
\begin{proof}
	已有结果表明，对任意的$\mu$-句子$\varphi$和原子命题$p$，存在一个$\{p\}$-无关的$\mu$-句子$\varphi'$（即$\IR(\varphi', \{p\})$）使得\cite{d1996uniform}：
		\[
	\Hm \models \varphi' \mbox{ 当且仅当 } \exists \Hm' \in \Mod(\varphi) \mbox{ 使得 } \Hm \lrto_{\{p\}} \Hm'.
	\]
	
	这与本文遗忘的定义一致，因此上述结论成立。
\end{proof}

与模态S5和$\CTL$情形类似，下面给出$\mu$-演算下遗忘的基本公设：
\begin{itemize}
	\item[(\W)]  削弱： $\varphi \models \varphi'$;
	\item[(\PP)]  正支持：
	对任意的$\mu$-句子 $\eta$，若$\IR(\eta, V)$和 $\varphi \models \eta$则 $\varphi' \models \eta$；
	\item[(\NgP)]  负支持：对任意的 $\mu$-句子$\eta$，若$\IR(\eta, V)$和 $\varphi \not \models \eta$则 $\varphi' \not \models \eta$；
	\item[(\textbf{IR})]  无关性： $\IR(\varphi', V)$。
\end{itemize}
其中 $V\subseteq\cal A$、
$\varphi$为$\mu$-公式、 $\varphi'$是 从$\varphi$中遗忘掉$V$后得到的结果。

\begin{theorem}[表示性定理]\label{chapter06:thm:Rep}
	给定$\mu$-公式 $\varphi$、 $\varphi'$和 $\phi$， $V \subseteq \Ha$为原子命题的集合。
	下面的几个陈述是等价的：
	\begin{itemize}
		\item[(i)] $\varphi' \equiv \Muforget(\varphi, V)$,
		\item[(ii)] $\varphi'\equiv \{\phi \mid\varphi \models \phi \text{ 且 } \IR(\phi, V)\}$,
		\item[(iii)] 若$\varphi$、 $\varphi'$及 $V$和(i)、(ii)中的符号表示相同公式和原子命题的集合，则 (\W)、 (\PP)、 (\NgP) 和 (\textbf{IR}) 成立。
	\end{itemize}
\end{theorem}
\begin{proof}
	$(i) \LRto (ii)$. 为了证明这一结论成立，只需证明：
	\[
	\Mod(\Muforget(\varphi, V)) = \Mod(\{\phi \mid \varphi \models \phi, \IR(\phi, V)\}).\]
	$(\Rto)$ 对$\Muforget(\varphi, V)$的任意模型 $(\Hm',v')$ \\
	$\Rto$  $\exists(\Hm,v)$使得 $(\Hm,v) \models \varphi$和 $(\Hm,v) \lrto_V (\Hm',v')$ \hfill (定义\ref{chapter06:def:V:forgetting}) \\
	$\Rto$ 对于任意与$V$-无关且$\varphi \models \phi$的$\phi$都有 $(\Hm',v') \models \phi$ \\
	$\Rto$ $(\Hm',v') \models \{\phi \mid \varphi \models \phi, \IR(\phi, V)\}$
	
	$(\Lto)$ 由于$\IR(\Muforget(\varphi, V),V)$和$\varphi \models \Muforget(\varphi, V)$，由定义\ref{chapter06:def:V:forgetting}可知 $\{\phi \mid \varphi \models \phi, \IR(\phi, V)\} \models \Muforget(\varphi, V)$。
	
	$(ii) \Rto (iii)$. 为了方便，令$A = \{\phi \mid \varphi \models \phi, \IR(\phi, V)\}$。
	首先，对任意的$A$中的公式$\phi'$都有$\IR(\phi',V)$，所以有$\IR(A,V)$。
	因此，$\IR(\varphi', V)$。 其次，对任意的 $\phi'\in A$，都有$\varphi \models \phi'$，所以$\varphi \models \varphi'$。
	%The (\NgP) and (\PP) are obvious from $A$.
	第三， $\forall \phi$且$\IR(\phi, V)$，若$\varphi \models \phi$则 $\phi \in A$，因而$\varphi' \models \phi$。
最后， $\forall \phi$且 $\IR(\phi, V)$，若 $\varphi \not \models \phi$则 $\phi \not \in A$。因此，由定义\ref{chapter06:def:V:forgetting}和$V$-无关性可知$\varphi' \not \models \phi$。
	
	$(iii) \Rto (ii)$. (1) $\varphi' \models \{\phi \mid \varphi \models \phi, \IR(\phi, V)\}$  \hfill ((\PP))\\
	(2) $\{\phi \mid \varphi \models \phi, \IR(\phi, V)\} \models \varphi'$ \hfill ((\W)， (\textbf{IR}))\\
	$\Rto$ $\varphi'\equiv \{\phi \mid\varphi \models \phi, \IR(\phi, V)\}$ \hfill ((1)， (2)).
\end{proof}


定理\ref{chapter06:thm:Rep} 表明基本公设对$\mu$-演算下的遗忘是充分且必要的：基本公设能描述遗忘的结果，遗忘的结果具有基本公设里的性质。这与S5和$\CTL$下的情形相同。

D'Agostino 研究了 $\mu$-演算下的均匀插值，并指出 $\mu$-算具有均匀插值性质~\cite{d1996uniform,d2000logical,d2006modal}。换句话说，这意味着对任意的 $\mu$-句子 $\varphi$和有限的原子命题的集合$V\subseteq \Var(\varphi)$，都存在一个$V$-无关且与$\varphi$最接近的 $\mu$-句子 $\widetilde{\exists}V \varphi$。
%下文将证明，$\mu$-句子的均匀插值与遗忘等价。
值得注意的是，对于$\mu$-句子$\varphi$，上述定义的遗忘 $\Muforget(\varphi, V)$与 $\widetilde{\exists}V \varphi$\cite{d2006modal} 语义等价。

\begin{corollary}\label{cor:unifeqforget}
		令$V \subseteq \Ha$ 且$\varphi$ 为$\mu$-句子，则$\widetilde{\exists}V \varphi \equiv \Muforget(\varphi, V)$。
\end{corollary}
\begin{proof}
	显然$\varphi \models \Muforget(\varphi, V)$ 且$\Muforget(\varphi, V) \cap V = \emptyset$。
	此外，对任意的$\phi$，若$\varphi \models \phi$且$\IR(\phi, V)$，由定理~\ref{chapter06:thm:Rep}可知$\Muforget(\varphi, V) \models \phi$。 
	
因此，由均匀插值的定义可知$\Muforget(\varphi, V)$是$\varphi$ 关于$\Var(\varphi)-V$的均匀插值。 
\end{proof}

除了上述的表示性定理，后文将说明公设(\textbf{IR})对计算SNC 和 WSC是重要的。对于$\mu$-句子$\psi = \varphi \wedge (q \lrto \alpha)$，$\varphi \wedge \alpha$是 $\{q\}$-无关的，则从$\psi$中遗忘掉 $q$得到的结果是$\varphi$。正如将在第\ref{chapter07}章中展示，这一性质有助于将任意公式的SNC（WSC）转换为命题下的SNC（WSC）。这一性质可形式化如下：

\begin{lemma}
	\label{lem:KF:eq}
	令 $\varphi$和 $\alpha$为两个 $\mu$-公式，$q$为原子命题且 $q \not \in  \Var(\varphi) \cup \Var(\alpha)$。则
	$\Muforget(\varphi \wedge (q\lrto\alpha), q)\equiv \varphi$。
\end{lemma}
 \begin{proof}
 		令$\varphi' =\varphi \wedge (q\lrto\alpha)$。对$\Muforget(\varphi', q)$的任意一个模型$({\cal M},v)$，存在一个赋值$({\cal M}',v')$ 使得 $({\cal M},v)\lrto_{\{q\}}({\cal M}',v')$ 且$({\cal M}',v') \models \varphi'$。显然，$({\cal M}',v') \models \varphi$，又因为$\IR(\varphi,\{q\})$ 且$({\cal M},v)\lrto_{\{q\}}({\cal M}',v')$，所以$({\cal M},v) \models \varphi$。
 	%	by the invariant of $\mu$-sentence for $\overline{V}$-bisimulation~\cite{d1996uniform}.
 	
 	令$(\Hm,v) \in \Mod(\varphi)$，其中${\cal M}=(S, s, R, L)$。如下构造$(\Hm',v')$，其中$\Hm' = (S, s, R, L')$且：
 	\begin{align*}
 		& L':S \rto 2^{\Ha}\hbox{且}\forall s^*\in S, \hbox{若}(\Hm, s^*) \not \models \alpha \hbox{，则}L'(s^*) = L(s^*) - \{q\}\hbox{，}\\
 		& \hbox{否则} L'(s^*) = L(s^*)\cup\{q\}\hbox{，} \\
 		& L'(s) = L(s) \cup\{q\}\hbox{若}(\Hm, s) \models \alpha\hbox{，}\hbox{否则}L'(s) = L(s)- \{q\}\hbox{。}
 	\end{align*}
 	显然，${\cal M}' \lrto_{\{q\}} \Hm$，所以$\Hm$和$\Hm'$之间存在一个$\{q\}$-互模拟关系$\Hb$。 
 	再者，对任意的$X\in {\cal V}$，令$v'(X) = \Hb(v(X))$。
 	
 	所以，$({\cal M}',v') \models \varphi$、$({\cal M}',v') \models q\lrto \alpha$且
 	$({\cal M},v)\lrto_{\{q\}}({\cal M}',v')$。因此，$({\cal M}',v') \models \varphi \wedge (q\lrto\alpha)$。又因为$({\cal M},v)\lrto_{\{q\}}({\cal M}',v')$ 且$\IR(\Muforget (\varphi \wedge (q\lrto\alpha), q), \{q\})$，从而$({\cal M},v) \models \Muforget (\varphi \wedge (q\lrto\alpha), \{q\})$。
% 	
%	令 $\varphi' =\varphi \wedge (q\lrto\alpha)$。对$\Muforget(\varphi', q)$的任意一个模型${\cal M}$，存在一个Kripke结构 ${\cal M}'$使得 ${\cal M}\lrto_{\{q\}}{\cal M}'$和 ${\cal M}' \models \varphi'$。显然有 ${\cal M}' \models \varphi$，又因为$\IR(\varphi,\{q\})$和 ${\cal M} \lrto_{\{q\}} {\cal M}'$，所以 ${\cal M} \models \varphi$。
%	%	by the invariant of $\mu$-sentence for $\overline{V}$-bisimulation~\cite{d1996uniform}.
%	
%	令 $\Hm \in \Mod(\varphi)$， 其中 ${\cal M}=(S, R, L, s)$。如下构造 $\Hm' = (S, R, L', s)$：
%	\begin{align*}
%		& L':S \rto 2^{\Ha}\hbox{且}\forall s^*\in S, \hbox{若}(\Hm, s^*) \not \models \alpha \hbox{，则}L'(s^*) = L(s^*) - \{q\}\hbox{，}\\
%		& \hbox{否则} L'(s^*) = L(s^*)\cup\{q\}\hbox{，} \\
%		& L'(s) = L(s) \cup\{q\}\hbox{若}(\Hm, s) \models \alpha\hbox{，}\hbox{否则}L'(s) = L(s)- \{q\}\hbox{。}
%	\end{align*}
%	显然 ${\cal M}' \models \varphi$、 ${\cal M}' \models q\lrto \alpha$且
%	${\cal M}' \lrto_{\{q\}} {\cal M}$。因此， ${\cal M}' \models \varphi \wedge (q\lrto\alpha)$，又因为${\cal M}' \lrto_{\{q\}} {\cal M}$和 $\IR(\Muforget (\varphi \wedge (q\lrto\alpha), q), \{q\})$，所以 ${\cal M} \models \Muforget (\varphi \wedge (q\lrto\alpha), q)$。
\end{proof}


正如在第\ref{chapter01}章中所说的，遗忘在经典命题逻辑中首先被提出，并应用于各种领域。这里给出经典命题逻辑与$\mu$-演算下的遗忘之间的联系。

首先，回顾一下从命题公式$\varphi$中遗忘原子命题$p$得到的结果为$\Forget(\varphi, \{p\})\equiv \varphi[p/\bot] \vee \varphi[p/\top]$，且 $\Forget(\varphi, V\cup \{p\})$被递归地定义为： $\Forget(\Forget(\varphi, \{p\}),V)$，其中 $\Forget(\varphi, \emptyset) = \varphi$。
此外，对于给定的Kripke结构$\Hm = (S, R, L, r)$和命题公式$\psi$，$\Hm \models  \psi$当且仅当$L(r) \models \psi$。经典命题逻辑与$\mu$-演算下的遗忘之间的联系如下：
\begin{theorem}\label{thm:PL:CTL}
	令$\varphi$为命题公式，$V\subseteq \Ha$为原子命题的集合，则
	\[
	\Muforget(\varphi, V) \equiv \Forget(\varphi, V).
	\]
\end{theorem}
\begin{proof}
	令 $\Hm = (S, R, L, r)$和 $\Hm' = (S', R', L', r')$为Kripke结构。
	%容易看出一个 Kripke 结构 $\Hm$$\psi$, i.e., $\Hm \models \psi$, if $L(r)$ satisfies $\psi$.
	
	$(\Rto)$ 对任意的 $\Hm \in \Mod(\Muforget(\varphi, V))$ \\
	$\Rto$ 由定义\ref{def:V:forgetting}可知存在$\Hm' \in \Mod(\varphi)$使得 $\Hm \lrto_V \Hm'$， %(by a $V$-bisimulation ${\cal B}$) by Def.
	 且$\Hm$和$\Hm'$之间的$V$-互模拟关系为 ${\cal B}$\\
	$\Rto$ $r {\cal B} r'$ \\
	$\Rto$ $\Hm \models \Forget(\varphi, V)$ \hfill ($\IR(\Forget(\varphi, V),V)$, $V$-无关性)
	
	$(\Lto)$ 对任意的 $\Hm \in \Mod(\Forget(\varphi, V))$ \\
	$\Rto$ $\exists \Hm' \in\Mod(\varphi)$使得$\forall p \in \Ha-V$， $p \in L(r)$当且仅当 $p \in L'(r')$ \hfill ($\Forget$的定义)\\
	%$r {\cal B} r'$\\
	
	如下构造 Kripke 结构 $\Hm_1 = (S_1, R_1, L_1, r_1)$：
	\begin{itemize}
		\item[*] $S_1 = (S - \{r\}) \cup \{r_1\}$,
		\item[*] $R_1$与$R$相同，除了$r$被$r_1$替换，且
		\item[*] $L_1$与 $L$相同，除了$L_1(r_1) = L'(r')$。
	\end{itemize}
	% $S_1 = (S - \{r\}) \cup \{r_1\}$, $R_1$ is the same as $R$ except that $r$ is replaced by $r_1$, and $L_1$ is the same as $L$ except $L_1(r_1) = L'(r')$. \\
	$\Rto$ $\Hm_1 \models \varphi$且 $\Hm_1 \lrto_V \Hm$\\
	$\Rto$ $\Hm \models \Muforget(\varphi, V)$ \hfill ($\IR(\Muforget(\varphi, V), V)$, $V$-无关性）
\end{proof}

定理\ref{thm:PL:CTL}表明$\mu$-演算下的遗忘是命题逻辑下遗忘的扩展，这提示我们是否命题情形下遗忘拥有的性质$\mu$-演算下的遗忘也具有。
下面的性质在命题逻辑、S5~\cite{Yan:AIJ:2009} 和$\CTL$中都成立，这里证明其在$\mu$-演算中也成立。
\begin{proposition}
	\label{chapter06:pro:ctl:forget:1}
	给定$\mu$-公式$\varphi$、$\varphi_i$和 $\psi_i$（$i=1,2$），$V\subseteq \Ha$为原子命题的集合。则：
	\begin{itemize}
		\item[(i)] $\Muforget(\varphi, V)$是可满足的当且仅当$\varphi$是可满足的；
		\item[(ii)] 若 $\varphi_1 \equiv \varphi_2$，则 $\Muforget(\varphi_1, V) \equiv \Muforget(\varphi_2, V)$；
		\item[(iii)] 若 $\varphi_1 \models \varphi_2$，则 $\Muforget(\varphi_1, V) \models \Muforget(\varphi_2, V)$；
		\item[(iv)] $\Muforget(\psi_1 \vee \psi_2, V) \equiv \Muforget(\psi_1, V) \vee \Muforget(\psi_2, V)$；
		\item[(v)] $\Muforget(\psi_1 \wedge \psi_2, V) \models \Muforget(\psi_1, V) \wedge \Muforget(\psi_2, V)$；
		\item[(vi)] $\Muforget(\varphi_1 \wedge \varphi_2, V) \equiv \Muforget(\varphi_1, V) \wedge \varphi_2$ 若$\IR(\varphi_2, V)$。
	\end{itemize}
\end{proposition}
\begin{proof}
	(i) $(\Hm,v) \in \Mod(\Muforget(\varphi, V))$\\
	$\LRto$ $\exists (\Hm',v') \in \Mod(\varphi)$ 使得$(\Hm, v) \lrto_V (\Hm',v')$。
	
	因为$\varphi \models \Muforget(\varphi, V)$，所以$(\Hm,v) \in \Mod(\varphi)$ 蕴涵$(\Hm,v) \models \Muforget(\varphi, V)$。\\
	
	
	(ii) 和 (iii) 可以类似地证明。
	
	(iv)  $(\Hm,v)\in \Mod(\Muforget(\varphi_1 \vee \varphi_2, V))$\\
	$\LRto$ 存在$(\Hm',v')$ $\in$  $\Mod(\varphi_1\vee \varphi_2)$使得$(\Hm,v) \lrto_V (\Hm',v')$ 和$(\Hm',v') \models \varphi_1$ 或$(\Hm',v') \models \varphi_2$ \\
	%$\LRto$ $\exists (\Hm_1,v_1) \in \Mod(\Muforget(\varphi_1, V))$ s.t. $(\Hm',v') \lrto_V (\Hm_1,v_1)$, or $\exists(\Hm_2,v_2) \in \Mod(\Muforget(\varphi_2, V))$ s.t. $(\Hm',v') \lrto_V (\Hm_2,v_2)$ \\
	$\LRto$ 存在$(\Hm,v) \lrto_V (\Hm',v')$ 使得$(\Hm',v') \models \varphi_1$ 或$(\Hm',v') \models \varphi_2$，则存在$(\Hm_1,v_1) \in \Mod(\Muforget(\varphi_1, V))$ 使得$(\Hm',v') \lrto_V (\Hm_1,v_1)$，或$\exists(\Hm_2,v_2) \in \Mod(\Muforget(\varphi_2, V))$ 使得$(\Hm',v') \lrto_V (\Hm_2,v_2)$\\
	%$\Rto$ $(\Hm,s) \lrto_V (\Hm_1,s_1)$ or $(\Hm,s) \lrto_V (\Hm_2,s_2)$\\
	$\LRto$ $(\Hm,v) \models \Muforget(\varphi_1, V)$或$(\Hm,v) \models  \Muforget(\varphi_2, V)$\\
	%$\Rto$ $(\Hm,v) \models \Muforget(\psi_1, V) \vee \Muforget(\psi_2, V)$\\
	$\LRto$ $(\Hm,v) \models \Muforget(\varphi_1, V) \vee \Muforget(\varphi_2, V)$。
	\\
	
	
	 (v)可以像 (iv)一样证明。
	 
	 (vi) $(\Hm,v) \models \Muforget(\varphi_1 \wedge \varphi_2,V)$\\
	 $\LRto$ 存在$(\Hm, v) \lrto_V (\Hm',v')$ 使得$(\Hm',v') \models \varphi_1 \wedge \varphi_2$\\
	 $\LRto$ 存在$(\Hm, v) \lrto_V (\Hm',v')$ 使得$(\Hm', v') \models \varphi_1$ 和$(\Hm', v') \models \varphi_2$\\
	 $\LRto$  $(\Hm, v) \models \Muforget(\varphi_1,V)$ 且$(\Hm,v) \models \varphi_2$ \hfill ($\IR(\varphi_2, V)$)\\
	 $\LRto$ $(\Hm,v) \models \Muforget(\varphi_1,V) \wedge \varphi_2$。
\end{proof}

命题\ref{chapter06:pro:ctl:forget:1}(i) 表明从一个$\mu$-句子中遗忘掉一些原子命题不影响该句子的可满足性；从(ii)可以看出，如果两个句子是等价的，则他们遗忘相同原子命题得到的结果是等价的； (iv)指出析取公式 $\varphi_1 \vee \varphi_2$的遗忘可以由分开计算遗忘后在析取而得到；而正如 (v) 中指出的那样，合取公式 $\psi_1 \wedge \psi_2$的遗忘不能分别计算再合取，这甚至对于命题公式都是不成立。
例：令$\varphi=p \wedge (q \vee \neg p)$，从$\varphi$中遗忘掉$p$的结果为$q$，但是$\Forget(p, \{p\}) \wedge \Forget(q\vee \neg p, \{p\}) \equiv \top$。显然二者不等价。

%\subsubsection{Other Semantic Properties}



下面是关于$\mu$-演算下遗忘算子的其他性质。


\begin{proposition}[分解性]\label{chapter06:disTF}  给定$\mu$-句子 $\varphi$、原子命题的集合$V$和原子命题 $p$且 $p \notin V$，则：
	\[
	\Muforget(\varphi, \{p\} \cup V) \equiv \Muforget(\Muforget(\varphi, \{p\}), V).
	\]
\end{proposition}
\begin{proof}
	令$(\Hm_1,v_1)$（${\cal M}_1=(S_1, R_1, L_1, s_1)$）为 $\Muforget(\varphi, \{p\} \cup V)$的模型。由遗忘的定义可知，存在$\varphi$的一个模型 $(\Hm,v)$（${\cal M} = (S, R,L, s)$） 使得 $(\Hm_1,v_1)$ $\lrto_{\{p\} \cup V}$ $(\Hm,v)$。如下构造Kripke结构 ${\cal M}_2 = (S_2, R_2, L_2, s_2)$：
	\begin{itemize}
		\item[(1)] 对于$s_2$，令$s_2$为满足下列条件的状态：
		\begin{itemize}
			\item $p \in L_2(s_2)$当且仅当$p \in L_1(s_1)$，
			\item 对任意的$q \in V$，$q \in L_2(s_2)$当且仅当 $q\in L(s)$，
			\item 对于其他的原子命题 $q'$， $q' \in L_2(s_2)$当且仅当 $q' \in L_1(s_1)$当且仅当 $q'\in L(s)$。
		\end{itemize}
		\item[(2)] 其他情形：假定$\Hm_1$和$\Hm$有$\{p\} \cup V$-互模拟关系${\cal B}$。
		\begin{itemize}
			\item[(i)] 对任意的 $w \in S$和 $w_1 \in S_1$且 $(w,w_1)\in {\cal B}$，令$w_2 \in S_2$和
			\begin{itemize}
				\item $p \in L_2(w_2)$当且仅当 $p \in L_1(w_1)$，
				\item 对任意的$q \in V$，$q \in L_2(w_2)$当且仅当 $q\in L(w)$，
				\item 对其他原子命题$q'$，$q' \in L_2(w_2)$当且仅当 $q' \in L_1(w_1)$当且仅当 $q'\in L(w)$。
			\end{itemize}
			\item[(ii)] 若$(w_1', w_1)\in R_1$，且$w_2$是由 $w_1$构造，$w_2'\in S_2$由 $w_1'$构造，则$(w_2', w_2)\in R_2$。
			%And if $w' \Hr^i w$, $w_2$is constructed based on $w$ and $w_2'\in \Hw_2$ is constructed based on $w'$, then $w_2' \Hr_2^i w_2$
			%\item if $\exists w_1'\in \Hw_1$ such that $w_1' \Hr_1 w_1$, then let $w_2' \in \Hw_2$, $w_2' \Hr_2 w_2$, and if $w_1' \neq s_1$ then do (i) for $w_2'$, else let$w_2' = s_2$.
		\end{itemize}
		\item 删除 $S_2$和 $R_2$中重复的元素。
	\end{itemize}
	可以容易检查 $\Hm \lrto_{\{p\}} \Hm_2$和 $\Hm_2 \lrto_V \Hm_1$。
	%因此，$(\Hm_2, s_2) \models \Muforget(\varphi, p)$，所以 $(\Hm_1, s_1) \models \Muforget(\Muforget(\varphi, p), V)$。
	此外，对所有的 $X \in {\cal V}$，令$v_2(X) = \Hb_1(v(X))$。
	因此，$(\Hm,v) \lrto_{\{p\}} (\Hm_2,v_2)$ 且$(\Hm_2,v_2) \lrto_V (\Hm_1,v_1)$，从而$(\Hm_2, s_2) \models \Muforget(\varphi, p)$。所以，$(\Hm_1, v_1) \models \Muforget(\Muforget(\varphi, p), V)$。
	
	另一方面，假设$(\Hm_1,v_1)$是$\Muforget(\Muforget(\varphi, p), V)$的一个模型\\
	$\Rto$ 存在$(\Hm_2,v_2)$使得$(\Hm_2,v_2) \models  \Muforget(\varphi, p)$ 且$(\Hm_2,v_2) \lrto_V (\Hm_1,v_1)$ \hfill(定义\ref{chapter06:def:V:forgetting})\\
	$\Rto$ 存在$(\Hm,v)$ 使得$(\Hm,v) \models \varphi$ 且$(\Hm,v) \lrto_{\{p\}} (\Hm_2,v_2)$ \hfill(定义\ref{chapter06:def:V:forgetting})。 
	
	因此，由命题\ref{pro:EqUnion} (iii)可知$(\Hm,v) \lrto_{\{p\} \cup V} (\Hm_1,v_1)$，所以$(\Hm_1,v_1) \models \Muforget(\varphi, \{p\} \cup V)$。
\end{proof}


下面这一性质为上述命题的推论。

\begin{corollary}[切片性]\label{chapter06:disTFV}
	给定$\mu$-句子$\varphi$和原子命题的集合 $V_i\subseteq{\cal A}~(i=1,2)$，有：
	\[
	\Muforget(\varphi, V_1 \cup V_2) \equiv \Muforget(\Muforget(\varphi, V_1), V_2).
	\]
\end{corollary}

$\Muforget$的另一个属性是关于$\ALL\NEXT$和 $\EXIST \NEXT$时序算子的：形如$\ALL\NEXT \varphi$或 $\EXIST \NEXT \varphi$的$\mu$-句子的遗忘可以提到$\ALL\NEXT$和 $\EXIST \NEXT$后面计算。而对于$\mu X. \varphi$和$\nu X. \varphi$就没有这样的性质，因为$\varphi$显然不是一个$\mu$-句子。


\begin{proposition}[同质性]\label{chapter06:pro:mu:forget:2}
	给定原子命题集合$V\subseteq\cal A$和$\mu$-公式 $\varphi$，则: % and $Q\in \{\EXIST, \ALL\}$.
	\begin{itemize}
		\item[(i)] $\Muforget(\ALL\NEXT\varphi,V)\equiv \ALL\NEXT \Muforget(\varphi,V)$；
		\item[(ii)] $\Muforget(\EXIST\NEXT\varphi,V)\equiv\EXIST\NEXT \Muforget(\varphi,V)$；
	\textcolor{red}{\item[(iii)] $\Muforget(\mu X. \varphi, V) \equiv \mu X. \Muforget(\varphi, V)$；}
		\item[(iv)] $\Muforget(\nu X. \varphi, V) \equiv \nu X. \Muforget(\varphi, V)$。
	\end{itemize}
\end{proposition}
\begin{proof}
	令$(\Hm,v)$（$\Hm=(S, r,R, L)$）、$(\Hm_i, v_i)$（$\Hm_i = (S_i, r_i, R_i, L_i)$） 和$(\Hm',v')$（$\Hm'=(S', r', R', L')$）为赋值，其中$i\in \mathbb{N}$。
%	若 $r'$为$\Hm$中的一个状态，则称$(\Hm_{r'},v')$ 
%	%, in which the root of $\Hm_{r'} = (S', r', R', L')$ is $r'$, 
%	为$(\Hm,v)$以$r'$为根的子结构，其中$\Hm_{r'} = (S', r', R', L')$且 
%	%if:
%	\begin{itemize}
%		\item %$S' \subseteq S$ and 
%		$S'=\{t \in S \mid t$从$r'$可达$\}\ \cup $ $\{s''\in S  \mid s''$从$r$和$r'$都不可达$\}$，
%		\item $R' =\{(s_1, s_2)\mid s_1, s_2 \in S'$且$(s_1, s_2) \in R\}$，
%		\item $L': S' \rto 2^\Ha$且$\forall s_1 \in S'$有$L'(s_1) = L(s_1)$，
%		% \item $r'$ is $r$ or a state reachable from $r$, and
%		\item $v'(X) = v(X) \cap S'$. % for every $X\in {\cal V}$, where $S_{r'} \subseteq S $ is the set of states that can not be reached from $r'$ but in $v(X)$.
%	\end{itemize}
%	显然，对任意的$\mu$-公式$\varphi$和$s \in S$（$S\in \Hm$），$(\Hm, s, v) \models \varphi$ 当且仅当$(\Hm_s, v') \models \varphi$。
%	%We denote $\exists_{sub}$ as ``there exists a sub-structure" and $\forall_{sub}$ as "for each sub-structure".
	
	(i) 
	$(\Rto)$ $(\Hm,v) \models \Muforget(\ALL\NEXT \varphi, V)$\\
	$\Rto$ 存在$(\Hm,v) \lrto_V (\Hm', v')$ 且$(\Hm', v') \models \ALL\NEXT \varphi$\\
	$\Rto$ 存在$(\Hm,v) \lrto_V (\Hm', v')$ 且对任意的$(r', r'') \in R'$，$(\Hm',r'', v') \models \varphi$\\
	$\Rto$ 对任意的$(r,r_1)\in R$，存在$(r', r_1') \in R'$ 使得$(\Hm,r_1, v) \lrto_V (\Hm',r_1',v')$ 且对任意的$(r', r'') \in R'$，$(\Hm',r'', v') \models \varphi$\\
	$\Rto$ 对任意的$(r,r_1)\in R$，存在$(\Hm,r_1, v) \lrto_V (\Hm',r_1',v')$ 且$(\Hm',r_1',v') \models \varphi$\\
	$\Rto$ 对任意的$(r,r_1)\in R$，$(\Hm,r_1, v) \models \Muforget(\varphi,V)$ \hfill ($\IR(\Muforget(\varphi,V), V)$)\\
	$\Rto$ $(\Hm,v)\models \ALL \NEXT (\Muforget(\varphi,V))$。
	
	$(\Lto)$ $(\Hm,v) \models \ALL \NEXT \Muforget(\varphi,V)$\\
	$\Rto$ 对任意的$(r, r_1) \in R$，$(\Hm,r_1,v) \models \Muforget(\varphi,V)$\\
	$\Rto$ 对任意的$(r, r_1) \in R$，存在$(\Hm,r_1,v) \lrto_V (\Hm', r', v')$ 且$(\Hm', r', v') \models \varphi$\\
	$\Rto$ 对任意的$i \geq 0$，存在$(\Hm,r_i,v) \lrto_V (\Hm_i', r_i',v_i')$ 且$(\Hm_i', r_i', v_i') \models \varphi$，其中$\{r_0, r_1, \dots\} = \{s\mid (r, s) \in R\}$，$\Hm_i' = (S_i', r_i', R_i', L_i')$（假定当$i \not = j$时，$S_i' \cap S_j'= \emptyset$） %, $v'(X) = \Hb_i(v(X))$ for every $X \in {\cal V}$, 
	，$\Hb_i$是$(\Hm,r_i,v)$ 和$(\Hm_i', r_i', v_i')$之间的Var-$V$-互模拟关系\\
	$\Rto$ $(\Hm^*, v^*) \lrto_V (\Hm,v)$ 且$(\Hm^*, v^*) \models \ALL\NEXT \varphi$，其中$\Hm^* = (S^*, r, R^*,L^*)$且
	\begin{itemize}
		\item $S^* = \{r\} \cup \bigcup_{i\geq 0} S_i'$,
		\item $R^* = \{(r, r_i') \mid i \geq 0\} \cup \bigcup_{i\geq 0} R_i'$,
		\item 对任意的$s \in S^*$，$L^*(s) = \bigcup_{i\geq 0} L_i'(s)$，且$L^*(r) = L(r)$，
		\item 对任意的$X \in {\cal V}$，
		\[v^*(X) = 
		\left\{
		\begin{array}{ll}
			\bigcup_{i\geq 0} v_i(X), \ \ \qquad \qquad \quad \hbox{若$r \not \in v(X)$；} \\
			\bigcup_{i\geq 0} v_i(X) \cup \{r\}, \ \ \ \quad \ \ \ \hbox{否则。}
		\end{array}
		\right.
		\]
	\end{itemize} 
	$\Rto$ $(\Hm,v) \models \Muforget(\ALL\NEXT \varphi, V)$。
	\\
	
	
	
	(ii)可类似于(i)证明。
%	$(\Rto)$ $(\Hm,s)\models\CTLforget(\EXIST\NEXT\phi,V)$\\
%	$\Rto$ 有 $(\Hm,s)\lrto_V(\Hm',s')$且 $(\Hm',s')\models \EXIST\NEXT\phi$，即$\Hm$和$\Hm'$之间存在$V$-互模拟关系$\Hb_V$\\
%	$\Rto$ 有$(\Hm,s)\lrto_V(\Hm',s')$，且对一些 $(s',s'')\in R'$有$(\Hm',s'')\models \phi$（$R'\in\Hm'$）\\
%	$\Rto$ 对一些 $(s,s_1)\in R$，有 $(s',s'_1)\in R'$和 $(s_1, s_1') \in \Hb_V$，且对一些$(s',s'')\in R'$有
%	$(\Hm',s'')\models \phi$（$R\in \Hm$）\\
%	$\Rto$ 对一些 $(s,s_1)\in R$，有 $(s_1, s_1') \in \Hb_V$和 $(\Hm',s'_1)\models\phi$\\
%	$\Rto$ 对一些 $(s,s_1)\in R$，有 $(\Hm,s_1)\models\CTLforget(\phi,V)$\\
%	$\Rto$ $(\Hm,s)\models\EXIST\NEXT\CTLforget(\phi,V)$。
%	
%	$(\Lto)$ $(\Hm,s)\models\EXIST \NEXT\CTLforget(\phi,V)$\\
%	$\Rto$ 对一些 $(s,s')\in R$， $(\Hm,s')\models\CTLforget(\phi,V)$（$R\in \Hm$）\\
%	$\Rto$ 对一些 $(s,s')\in R$，有$(\Hm,s')\lrto_V(\Hm',s'')$和 $(\Hm',s'')\models\phi$，其中 $\Hm'=(S',R',L',[\_]',s'')$ \\
%	%		$\Rto$ For every $i\ge 0$, there is $(\Hm,s'_i)\lrto_V(\Hm'_i,s''_i)$ and $(\Hm'_i,s''_i)\models\phi$
%	%		where $\{s'_0,s'_1,\ldots\}=\{s'\mid (s,s')\in R\}$ and $\Hm'_i=(S'_i,R'_i,L'_i,[\_]'_i,s''_i)$ (we assume $S'_i\cap S'_j=\emptyset$ when $i\neq j$)\\
%	$\Rto$ $(\Hm^*,s)\lrto_V(\Hm,s)$和 $(\Hm^*,s)\models\EXIST\NEXT\phi$，其中
%	$\Hm^*=(S^*,R^*,L^*,[\_], s)$，
%	\begin{itemize}
%		\item $S^*=S\cup S'$，
%		\item $R^*=\{(s,s'')\}\cup R \cup R'$，
%		\item $L^*= L \cup L'$和 $L^*(s)=L(s)$，其中 $L\in\Hm$。
%	\end{itemize}
%	$\Rto$ $(\Hm,s)\models \CTLforget(\EXIST\NEXT\phi,V)$。

	\textcolor{red}{(iii)} 
	
	(iv) $(\Rto)$ $(\Hm,v) \models \Muforget(\nu X. \varphi, V)$\\
	$\Rto$ 存在$(\Hm', v') \lrto_V (\Hm,v)$ 且$(\Hm',v') \models \nu X. \varphi$\\
	$\Rto$ $r' \in \bigcup \{S_1 \subseteq S' \mid S_1 \subseteq \left\|\varphi\right\|_{v'[X:=S_1]}^{\Hm'}\}$\\
	$\Rto$ 存在$S_1 \subseteq S'$ 使得$S_1 \subseteq \left\|\varphi\right\|_{v'[X:=S_1]}^{\Hm'}$、$r'\in S_1$和 $r'\in \left\|\varphi\right\|_{v'[X:=S_1]}^{\Hm'}$\\
	$\Rto$ $r' \in \left\|\Muforget(\varphi,V)\right\|_{v'[X:=S_1]}^{\Hm'}$ 且$S_1 \subseteq \left\|\Muforget(\varphi,V)\right\|_{v'[X:=S_1]}^{\Hm'}$ \hfill ($\varphi \models \Muforget(\varphi,V)$)\\
	$\Rto$ $r'\in \bigcup \{S_1 \subseteq S' \mid S_1 \subseteq \left\|\Muforget(\varphi,V)\right\|_{v'[X:=S_1]}^{\Hm'}\}$\\
	$\Rto$ $(\Hm',v')\models \nu X. \Muforget(\varphi,V)$\\
	$\Rto$ $(\Hm,v) \models \nu X. \Muforget(\varphi,V)$ \hfill  ($\IR(\nu X. \Muforget(\varphi,V), V)$)
	
	$(\Lto)$ $(\Hm,v)\models \nu X. \Muforget(\varphi,V)$\\
	$\Rto$ $r\in \bigcup \{S_1 \subseteq S \mid S_1 \subseteq \left\|\Muforget(\varphi,V)\right\|_{v[X:=S_1]}^{\Hm'}\}$\\
	$\Rto$ 存在$S_1 \subseteq S$ 使得$S_1 \subseteq \left\|\Muforget(\varphi,V)\right\|_{v[X:=S_1]}^{\Hm'}$ 且$r \in S_1$\\
	$\Rto$ 存在$(\Hm',v'[X:=\Hb(S_1)]) \lrto_V (\Hm,v[X:=S_1])$（其Var-$V$-互模拟关系为$\Hb$）使得$(\Hm',v'$ $[X:=\Hb(S_1)]) \models \varphi$ 且$\Hb(S_1) \subseteq \left\|\varphi\right\|_{v'[X:=\Hb(S_1)]}^{\Hm'}$\\
	$\Rto$ $r'\in \Hb(S_1)$ \hfill ($(r,r')\in \Hb$)\\
	$\Rto$ $r'\in \bigcup \{S_1' \subseteq S' \mid S_1' \subseteq \left\|\varphi\right\|_{v'[X:=S_1']}^{\Hm'}\}$\\
	$\Rto$ $(\Hm',v'[X:=S_{\Hb}]) \models \nu X. \varphi$ 且$(\Hm,v) \lrto_V (\Hm',v'[X:=S_{\Hb}])$，其中$S_{\Hb} \subseteq S'$ 且对任意的$(s,t)\in \Hb$， $s\in S_{\Hb}$ 当且仅当$t\in v(X)$\\
	$\Rto$ $(\Hm, v) \models \Muforget(\nu X. \varphi, V)$。
\end{proof}


 $\ALL\NEXT$（或 $\EXIST\NEXT$）在 $\Muforget$上的同质性表明，在从 $\ALL\NEXT \varphi$（或 $\EXIST\NEXT \varphi$）遗忘掉$V$中的原子命题等价于将$\Muforget$提到$\ALL\NEXT$和 $\EXIST \NEXT$后面计算的结果。
 (iii)和(iv)，遗忘原子命题与不动点操作是无关的。
%It offers convenience for computing the forgetting.
特别地，当命题\ref{chapter06:pro:mu:forget:2}中的公式$\phi$为命题公式时，从
$\ALL\NEXT \phi$ $(\EXIST\NEXT \phi)$ 或 $\mu X. \varphi$ 中遗忘原子命题可以使用命题逻辑的遗忘计算方法来计算。

前文证明了$\mu$-句子遗忘任意原子命题集合的结果总是$\mu$-句子。这里讨论一种$\mu$-公式的子类：不含有不定点操作的$\mu$-公式的集合，记为$\NEXT$-类。
通过等值式：$\ALL\NEXT \varphi_1 \wedge \ALL\NEXT \varphi_2 \equiv \ALL\NEXT (\varphi_1 \wedge \varphi_2)$ 和$\EXIST\NEXT \varphi_1 \vee \EXIST\NEXT \varphi_2 \equiv \EXIST\NEXT (\varphi_1 \vee \varphi_2)$，可以将$\NEXT$-类中的任意公式转换为具有下面形式的公式的析取：
\begin{align}
	\label{equ:form}
	\varphi_0 \wedge \ALL\NEXT \varphi_1 \wedge \EXIST\NEXT \varphi_2 \wedge \dots \wedge \EXIST \NEXT \varphi_n\hbox{，}
\end{align}
其中$\varphi_0$是$\NEXT$-类中不含有模态词的公式，$\varphi_i$ ($1\leq i \leq n$)为$\NEXT$-类中的公式，且
任意的$\varphi_i$ ($0\leq i \leq n$) 都有可能缺失。


\begin{lemma}\label{lem:geneq}
	令$V\subseteq \Ha$ 为原子命题的集合，$\varphi_0 \wedge \ALL\NEXT \varphi_1 \wedge \EXIST\NEXT \varphi_2 \wedge \dots \wedge \EXIST \NEXT \varphi_n$为具有形式 (\ref{equ:form})的可满足公式，则
	\begin{align*}
		\Muforget(\varphi_0 \wedge \ALL\NEXT \varphi_1 & \wedge \EXIST\NEXT \varphi_2 \wedge \dots \wedge \EXIST \NEXT \varphi_n,V) \\
		\equiv &\ \Muforget(\varphi_0, V) \wedge \Muforget(\ALL\NEXT \varphi_1, V) \wedge \bigwedge_{2\leq i\leq n}  \Muforget(\EXIST\NEXT(\varphi_i \wedge \varphi_1), V)\\
		\equiv &\  \Muforget(\varphi_0, V) \wedge \ALL\NEXT\Muforget(\varphi_1, V) \wedge \bigwedge_{2\leq i\leq n} \EXIST\NEXT \Muforget(\varphi_i \wedge \varphi_1, V).
	\end{align*}
\end{lemma}
\begin{proof}
	由命题~\ref{chapter06:pro:mu:forget:2}的(i)和(ii)可知，
	\begin{align*}
		& \Muforget(\varphi_0, V) \wedge \Muforget(\ALL\NEXT \varphi_1, V) \wedge \bigwedge_{2\leq i\leq n}  \Muforget(\EXIST\NEXT(\varphi_i \wedge \varphi_1), V)\\
		\equiv &\  \Muforget(\varphi_0, V) \wedge \ALL\NEXT\Muforget(\varphi_1, V) \wedge \bigwedge_{2\leq i\leq n} \EXIST\NEXT \Muforget(\varphi_i \wedge \varphi_1, V).
	\end{align*}
	
	($\Rto$) $(\Hm,v) \models \Muforget(\varphi_0 \wedge \ALL\NEXT \varphi_1 \wedge \EXIST\NEXT \varphi_2 \wedge \dots \wedge \EXIST \NEXT \varphi_n,V)$ \\
	$\Rto$ 存在$(\Hm, v) \lrto_V (\Hm', v')$ 使得$(\Hm',v') \models \varphi_0 \wedge \ALL\NEXT \varphi_1 \wedge \EXIST\NEXT \varphi_2 \wedge \dots \wedge \EXIST \NEXT \varphi_n$\\
	$\Rto$ $(\Hm',v') \models \varphi_0$、$(\Hm', v') \models \ALL\NEXT \varphi_1$和$(\Hm',v') \models \EXIST\NEXT \varphi_i$，其中$2\leq i \leq n$\\
	$\Rto$ $(\Hm',v') \models \varphi_0$、$(\Hm', v') \models \ALL\NEXT \varphi_1$和$(\Hm',v') \models \EXIST\NEXT (\varphi_i \wedge \varphi_1)$，其中$2\leq i \leq n$ \hfill ($(\Hm,v) \models \ALL\NEXT \varphi_1$)\\
	$\Rto$ $(\Hm,v) \models \Muforget(\varphi_0,V)$、$(\Hm, v) \models \Muforget(\ALL\NEXT \varphi_1, V)$和$(\Hm,v) \models \Muforget(\EXIST\NEXT (\varphi_i \wedge \varphi_1), V)$，其中$2\leq i \leq n$ \quad ($(\Hm, v) \lrto_V (\Hm', v')$, $\IR(\Muforget(\varphi_0,V),V)$, $\IR(\Muforget(\ALL\NEXT \varphi_1, V), V)$, $\IR(\Muforget(\EXIST\NEXT (\varphi_i \wedge \varphi_1), V), V)$)\\
	$\Rto$ $(\Hm,v) \models \Muforget(\varphi_0, V) \wedge \Muforget(\ALL\NEXT \varphi_1, V) \wedge \bigwedge_{2\leq i\leq n}  \Muforget(\EXIST\NEXT(\varphi_i \wedge \varphi_1), V)$
	
	$(\Lto)$ $(\Hm,v) \models \Muforget(\varphi_0, V) \wedge \Muforget(\ALL\NEXT \varphi_1, V) \wedge \bigwedge_{2\leq i\leq n}  \Muforget(\EXIST\NEXT(\varphi_i \wedge \varphi_1), V)$，其中$\Hm=(S,r, R,L)$\\
	$\Rto$ $(\Hm,v) \models \Muforget(\varphi_0, V) \wedge \ALL\NEXT\Muforget(\varphi_1, V) \wedge \bigwedge_{2\leq i\leq n} \EXIST\NEXT \Muforget(\varphi_i \wedge \varphi_1, V)$ \\
	$\Rto$ $(\Hm,r,v) \models \Muforget(\varphi_0, V)$，对任意的$(r, r')\in R$，$(\Hm, r', v) \models \Muforget(\varphi_1, V)$，且对任意的$2\leq i \leq n$，存在$(r, r'')\in R$ 使得$(\Hm,r'', v) \models \Muforget(\varphi_i \wedge \varphi_1, V)$\\
	$\Rto$ 存在$(\Hm',v) \models \varphi_0$ 且$(\Hm',v) \lrto_V (\Hm,v)$，其中$\Hm'=(S,r,R,L')$； 
	对任意的$(r, r_j)\in R$，存在$(\Hm_j',r_j',v_j')$ 使得$(\Hm_j',r_j',v_j') \lrto_V (\Hm,r_j, v)$ 且$(\Hm_j',r_j',v_j') \models \varphi_1$；且对任意的$(r, r_j)\in R$ 且$(\Hm,r_j, v) \models \Muforget(\varphi_i \wedge \varphi_1, V)$ ($2\leq i \leq n$)，存在$(\Hm_j', r_j', v_j') \lrto_V (\Hm,r_j,v)$ 使得$(\Hm_j', r_j', v_j')\models \varphi_i \wedge \varphi_1$  ($j\geq 0$，当 $x \not =y$时，假设$S_x \cap S_y = \emptyset$)， 其中$\{r_0, r_1, \dots\} = \{r'\mid (r,r')\in R\}$，$\Hm_j'=(S_j',r_j', R_j', L_j')$\\
	$\Rto$ There is $(\Hm^*,v^*) \lrto_V (\Hm,v)$ s.t. $(\Hm^*, v^*) \models \varphi_0 \wedge \ALL\NEXT \varphi_1 \wedge \bigwedge_{2\leq i\leq n}  \EXIST\NEXT(\varphi_i \wedge \varphi_1)$, where $\Hm^*=(S^*,r, R^*, L^*)$
	\begin{itemize}
		\item $S^* = \{r\} \cup \bigcup_{j\geq 0} S_j'$,
		\item $R^* = \{(r,r_j') \mid j \geq 0\}\cup \bigcup_{j\geq 0} R_j'$,
		\item $L^*(s) = L_j'(s)$ for $s\in S_j'$ and $L^*(r) = L'(r)$, and 
		\item for all $X \in {\cal V}$,
		\[v^*(X) = 
		\left\{
		\begin{array}{ll}
			\bigcup_{j\geq 0} v_j'(X), \ \ \qquad \qquad \quad \hbox{若$r \not \in v(X)$；} \\
			\bigcup_{j\geq 0} v_j'(X) \cup \{r\}, \ \ \ \quad \ \ \ \hbox{否则。}
		\end{array}
		\right.
		\]
	\end{itemize}
	$\Rto$ $(\Hm,v) \models \Muforget(\varphi_0 \wedge \ALL\NEXT \varphi_1 \wedge \EXIST\NEXT \varphi_2 \wedge \dots \wedge \EXIST \NEXT \varphi_n,V)$。
\end{proof}

给定$\NEXT$-类中的公式$\varphi$，公式$\varphi$的度（记为$degree(\varphi)$）定义如下：
\begin{align*}
	& degree(X) = degree(p) = degree(\neg p) = 0,\\ %\hbox{ where } X\in {\cal V} \hbox{ and } p \in \Ha,\\
	& degree(\ALL\NEXT \psi) = degree(\psi) + 1, \\
	& degree(\EXIST\NEXT \psi) = degree(\psi) + 1, \\
	& degree(\psi_1 * \psi_2) = \max\{degree(\psi_1), degree(\psi_2)\}, % \hbox{ with } * \in \{\vee, \wedge\}
\end{align*}
其中$X\in {\cal V}$、$p \in \Ha$和$* \in \{\vee, \wedge\}$。

\begin{proposition}\label{pro:axexclass}
	令$V\subseteq \Ha$为原子命题的集合、$\varphi$为$\NEXT$-类中的公式。存在$\NEXT$-类中的公式$\psi$使得$\psi \equiv \Muforget(\varphi, V)$。
\end{proposition}
\begin{proof}
	假定$degree(\varphi) = n$；通过归纳公式的度来证明这一结论。
	
	\textbf{基始.} $n=0$.
	令$\varphi$是一个可能含有自由变元的度为0的$\mu$-公式。  
	由定理~\ref{thm:PL:CTL}和命题~\ref{chapter06:pro:ctl:forget:1} (vi)可知$\Muforget(\varphi, V) = \Forget(\varphi, V)$。
	
	\textbf{归纳步.} 假设对所有$degree(\varphi_1) \leq k$的$\NEXT$-类中公式$\varphi_1$，$\Muforget(\varphi_, V)$在$\NEXT$-类中。证明对任意的公式$\varphi_2$且$degree(\varphi_2) = k+1$，$\Muforget(\varphi_2, V)$ 在$\NEXT$-类中。
	
	$\varphi_2$可以被转换为形如公式(\ref{equ:form})的公式的析取$\varphi'$，且$degree(\varphi') \leq k+1$（因为在转换过程中不会引入新的嵌套模态词）。
	
	不失一般性地，假设 $$\varphi' = \bigvee_{1\leq i\leq x} \varphi_{i,0} \wedge \ALL\NEXT \varphi_{i,1} \wedge \EXIST\NEXT \varphi_{i,2} \wedge \dots \wedge \EXIST \NEXT \varphi_{i,n_i},$$
	且$\varphi_{i,j}$ $(1\leq i\leq x, 1\leq j\leq n_i)$是$degree(\varphi_{i,j})\leq k$的公式。
	
	由引理~\ref{lem:geneq}和命题~\ref{chapter06:pro:ctl:forget:1}(iv)可知：
	\begin{align*}
		\Muforget(\varphi', V) & \equiv \bigvee_{1\leq i\leq x} \Muforget(\varphi_{i,0} \wedge \ALL\NEXT \varphi_{i,1} \wedge \EXIST\NEXT \varphi_{i,2} \wedge \dots \wedge \EXIST \NEXT \varphi_{i,n_i}, V) \\
		& \equiv \bigvee_{1\leq i\leq x}(\Muforget(\varphi_{i,0},V) \wedge \ALL\NEXT\Muforget(\varphi_{i,1},V) \wedge \bigwedge_{2\leq j \leq n_i}\EXIST\NEXT\Muforget(\varphi_{i,1} \wedge \varphi_{i,j},V))\hbox{。}
	\end{align*}
	
	因此，有归纳假设可知$\Muforget(\varphi', V)$在$\NEXT$-类中。 
\end{proof}

\begin{example}
	\label{exp:x-class}
	令$\varphi_1 = X \wedge p$、$\varphi_2 = \ALL\NEXT(c \wedge \EXIST\NEXT d) \wedge \ALL\NEXT e$、$\varphi_3 = \EXIST\NEXT \neg d \wedge (\EXIST\NEXT \neg p \vee \EXIST\NEXT p)$、$\varphi = \varphi_1 \wedge \varphi_2 \wedge \varphi_3$且$V = \{e,d\}$，其中$X \in {\cal V}$且$p, c, d, e$为原子命题。
	
	如下计算公式$\varphi$的度：
	\begin{align*}
		degree(\varphi) &  =  \max\{degree(\varphi_1), degree(\varphi_2 \wedge \varphi_3)\}\\
		& = \max\{0, \max\{degree(\varphi_2), degree(\varphi_3)\}\\
		& = 2,\\
		degree(\varphi_1) & = 0,\\
		degree(\varphi_2) & = \max\{degree(\ALL\NEXT(c \wedge \EXIST\NEXT d)), degree(\ALL\NEXT e)\}\\
		& =\max\{\max\{0, 1\} + 1, 1\}\\
		& = 2,\\
		degree(\varphi_3) & = \max\{degree(\EXIST\NEXT \neg d), degree(\EXIST\NEXT \neg p \vee \EXIST\NEXT p)\}\\
		& = \max\{1, \max\{1,1\}\}\\
		& = 1.
	\end{align*}
	此外，公式$\varphi$可如下转换为具有形式(\ref{equ:form})的公式的析取：
	\begin{align*}
		\varphi & = \varphi_1 \wedge \varphi_2 \wedge \varphi_3\\
		& \equiv X \wedge p \wedge \ALL\NEXT(c \wedge e \wedge \EXIST\NEXT d) \wedge \EXIST\NEXT \neg d \wedge (\EXIST\NEXT \neg p \vee \EXIST\NEXT p)\\
		& \equiv (X \wedge p \wedge \ALL\NEXT(c \wedge e \wedge \EXIST\NEXT d) \wedge \EXIST\NEXT \neg d \wedge \EXIST\NEXT \neg p) \vee\\
		& \quad\ (X \wedge p \wedge \ALL\NEXT(c \wedge e \wedge \EXIST\NEXT d) \wedge \EXIST\NEXT \neg d \wedge \EXIST\NEXT  p).
	\end{align*}
	则从$\varphi$中遗忘掉$V$的结果为：
	\begin{align*}
		\Muforget(\varphi,V) & \equiv \Muforget(X \wedge p \wedge \ALL\NEXT(c \wedge e \wedge \EXIST\NEXT d) \wedge \EXIST\NEXT \neg d \wedge \EXIST\NEXT \neg p, V) \vee \\
		& \qquad \Muforget(X \wedge p \wedge \ALL\NEXT(c \wedge e \wedge \EXIST\NEXT d) \wedge \EXIST\NEXT \neg d \wedge \EXIST\NEXT  p,V) \\
		& \equiv (X \wedge p \wedge \ALL\NEXT\Muforget(c \wedge e \wedge \EXIST\NEXT d, V) \wedge\\
		& \quad\EXIST\NEXT\Muforget(\neg d \wedge c \wedge e \wedge \EXIST\NEXT d, V) \wedge  \EXIST\NEXT\Muforget(\neg p \wedge c \wedge e \wedge \EXIST\NEXT d, V) )\vee \\
		& \quad (X \wedge p \wedge \ALL\NEXT\Muforget(c \wedge e \wedge \EXIST\NEXT d, V) \wedge\\
		& \quad\EXIST\NEXT\Muforget(\neg d \wedge c \wedge e \wedge \EXIST\NEXT d, V) \wedge  \EXIST\NEXT\Muforget( p \wedge c \wedge e \wedge \EXIST\NEXT d, V)) \\
		& \equiv (X \wedge p \wedge \ALL\NEXT c \wedge \EXIST\NEXT c \wedge \EXIST\NEXT (\neg p \wedge c)) \vee 
		(X \wedge p \wedge \ALL\NEXT c \wedge \EXIST\NEXT c \wedge \EXIST\NEXT (p \wedge c)) \\
		& \equiv X \wedge p \wedge \ALL\NEXT c \wedge \EXIST\NEXT c \wedge (\EXIST\NEXT (\neg p \wedge c) \vee \EXIST\NEXT (p \wedge c)).
	\end{align*}
\end{example}

\section{计算复杂性}
析取$\mu$-公式$\varphi$的均匀插值为 $\widetilde{\exists}p \varphi$（$p\in \Ha$），且与 $\varphi[p/\top,\neg p/\top]$等价~\cite{d2006modal}，其中$\varphi[p/\top,\neg p/\top]$表示将$\varphi$中的$p$和$\neg p$同时用$\top$替换。
正如之前说过的 $\Muforget(\varphi, V)$与均匀插值 $\widetilde{\exists}V \varphi$等价\cite{d2006modal}。因此，下面的命题容易证明。
\begin{corollary}\label{pro:disLiT}
	给定$\mu$-句子$\varphi$和原子命题 $p\in \Ha$。若$\varphi$是一个析取 $\mu$-句子， $\Muforget(\varphi, \{p\})$能在线性时间内计算。
\end{corollary}
\begin{proof}
	content...
\end{proof}

这种情况下，可以首先将一个$\mu$-句子转化为析取$\mu$-公式，再去计算遗忘。
下面的例子给出如何计算从析取$\mu$-公式中遗忘 “$ch$”。
\begin{example}
	令$\varphi_1=  j \wedge ch \wedge Cover(\neg j \wedge \neg ch, \top)$、 $\varphi_2= \mu X. (j \wedge ch) \wedge Cover(X, \top)$、 $\varphi_3=  \nu X. (j \wedge ch) \wedge Cover(Cover(X,$ $\top), \top)$。令$V=\{ch\}$，我们能容易地计算从这些公式里遗忘掉$V$。
	
	(1) $\Muforget(\varphi_1, V) \equiv j \wedge Cover(\neg j, \top) \equiv j \wedge \EXIST \NEXT(\neg j)$；
	
	(2) $\Muforget(\varphi_2, V) \equiv \mu X. j  \wedge Cover(X, \top) \equiv \mu X. j \wedge \EXIST \NEXT X$；
	
	(3) $\Muforget(\varphi_2, V) \equiv \nu X. j \wedge Cover(Cover(X, \top), \top) \equiv \nu X. j \wedge \EXIST \NEXT(\EXIST \NEXT X)$。
\end{example}

%Nevertheless, we will show that the model checking problem of forgetting is intractable even if the given formula is disjunctive.
尽管如此，关于遗忘的模型检测（即：检查一个结构是否为从$\mu$-句子中遗忘掉某个原子命题的集合的模型）也是不容易的。
\begin{proposition}[模型检测]\label{chapter06:pro:MC}
	给定一个有限的 Kripke 结构  $\Hm$、一个 $\mu$-句子 $\varphi$和原子命题的集合 $V\subseteq \Ha$。有：
	\begin{itemize}
		\item[(i)] 判定 $\Hm \models^? \Muforget(\varphi, V)$在$\textsc{Exptime}$中；
		\item[(ii)] 若 $\varphi$是一个析取 $\mu$-公式，则判定 $\Hm \models^? \Muforget(\varphi, V)$在 \textsc{NP}$\cap$co-\textsc{NP}中。
	\end{itemize}
\end{proposition}
\begin{proof}
	对于一个$\mu$-公式$\varphi$，如果该公式为一个析取$\mu$-公式可在多项式时间内构造一个 $\mu$-自动机（也叫模态自动机~\cite{bradfield2018mu}） $A_{\varphi}$，否则需要指数时间构造其对应的$\mu$-自动机\footnote{个人通信: Giovanna D'Agostino, 2020.}.
	这里证明(ii)，(i)可以类似地证明。
	
	令$A_{\varphi}$为一个$\mu$-自动机 且满足对任意的 Kripke ${\cal N}$， %there is
	$A_{\varphi}$接受 ${\cal N}$当且仅当 ${\cal N} \models \varphi$，其中 $A_{\varphi} = (Q, \Sigma_p, \Sigma_r, q_0, \delta, \Omega)$、 $\Sigma_p = \Var(\varphi)$。不是一般性地，假定$V \subseteq \Var(\varphi)$和 $V=\{p\}$。因此，构造一个 $\mu$-自动机 ${\cal B}= (Q, \Sigma_p - V, \Sigma_r, q_0, \delta', \Omega)$使得对任意的$q\in Q$和 $L\subseteq \Sigma_p - V$，
	\[
	\delta'(q, L) = \delta(q, L) \cup \delta(q, L \cup \{p\}).
	\]
	
	已有结论表明，对任意的Kripke结构${\cal N}$， ${\cal B}$接受 ${\cal N}$当且仅当存在$\varphi$的一个模型${\cal N}'$使得${\cal N} \lrto_{\{p\}} {\cal N}'$~\cite{d1996uniform}，即${\cal B}$对应于和$\Muforget(\varphi, V)$等价的$\mu$-句子。
	
	
	在这种情况下，判定 $\Hm \models^? \Muforget(\varphi, V)$问题被归约到判定是否 ${\cal B}$接受 $\Hm$的问题。
	而${\cal B}$从根$r$接受一个Kripke结构$\Hm=(S, R,L, r)$当且仅当Eve在参数游戏（parity game）${\cal G}(\Hm, \Ha)$上有一个从$(r,q^0)$开始的赢的策略，这一问题在\textsc{NP}$\cap$co-\textsc{NP}~\cite{bradfield2018mu}中。
	%In this case, the problem $\Hm \models^? \Muforget(\varphi, V)$ is reduced to decide whether $B$ accepts $\Hm$, which is in \textsc{NP}$\cap$co-\textsc{NP}~\cite{bradfield2018mu}.
\end{proof}

给定$\mu$-句子 $\varphi$和 $\psi$， $V$为原子命题的集合。从知识进化的角度来看，以下推理问题（在命题逻辑里也有研究~\cite{wang2015forgetting}） 是值得探索的：
%we are also interested in the following reasoning problems about forgetting, which are explored in CPL~\cite{wang2015forgetting}:

\begin{itemize}
	\item[(i)] $[$Var-weak$]$ $\varphi$在$\psi$的原子命题上的约束至多有$\psi$强，即$\psi\models \Muforget(\varphi, V)$；
	\item[(ii)] $[$Var-strong$]$ $\varphi$在$\psi$的原子命题上的约束至少有$\psi$强，即$\Muforget(\varphi, V)\models \psi$；
	\item[(iii)] $[$Var-entailment$]$ $\varphi$在$\Var(\varphi) \cap \Var(\psi)$上的约束比$\psi$在$\Var(\varphi) \cap \Var(\psi)$上的约束强，即 $\Muforget(\varphi, V) \models \Muforget(\psi, V)$,
\end{itemize}
% where $\varphi$, $\psi$ are $\mu$-sentences, and $V$ is a set of atoms. 
%值得注意的是，在(i)和(ii)中， $\Var(\varphi) - V = \Var(\psi)$，在(iii)中， $V \subseteq (\Var(\varphi) \cap \Var(\psi))$。

\begin{theorem}[Entailment]
	\label{thm:Ent}
	给定$\mu$-句子$\varphi$和 $\psi$，$V$为原子命题的集合，则下面的判定问题为 $\textsc{Exptime}$-完全的。
	\begin{itemize}
		\item[(i)] 判定  $\Muforget(\varphi, V ) \models^? \psi$，
		\item[(ii)] 判定  $\psi \models^? \Muforget(\varphi, V)$，
		\item[(iii)] 判定 $\Muforget(\varphi, V) \models^? \Muforget(\psi, V)$。
	\end{itemize}
\end{theorem}
\begin{proof}	
	在$\textsc{Exptime}$中. 令 $A_{\varphi}$和 $A_{\psi}$分别为$\varphi$和 $\psi$的$\mu$-自动机，由命题\ref{chapter06:pro:MC}的证明可从 $A_{\varphi}$构造 $\Muforget(\varphi, V )$的$\mu$-自动机 ${\cal B}$。由命题 7.3.2~\cite{comon1997tree}可知，可以在线性时间内构造$A_\psi$的补自动机$C$，因此可以在线性时间内构造$C$和 ${\cal B}$的交自动机$A_{C \cap {\cal B}}$。此时，判定问题 $\Muforget(\varphi, V ) \models^? \psi$被规约称判定 $A_{C \cap {\cal B}}$接受的语言是否为空，这一问题时$\textsc{Exptime}$-完全的 (定理 7.5.1~\cite{comon1997tree})。
	
	因此，判定是否$\Muforget(\varphi, V ) \models^? \psi$是$\textsc{Exptime}$的。 
	
	$\textsc{Exptime}$-难. $\Muforget(\varphi, V ) \models \psi$ 当且仅当$\neg \Muforget(\varphi, V) \vee \psi$是有效的。令$\psi \equiv \bot$， $\Muforget(\varphi, V ) \models \bot$ 当且仅当$\varphi \models \bot$，判定$\varphi \models^? \bot$是$\textsc{Exptime}$-完全的~\cite{bradfield2018mu}。
	因此原问题是$\textsc{Exptime}$-完全的。
	
	% 对任意的 $\mu$-句子存在一个等价的 $\mu$-自动机，且对任意的 $\mu$-自动机存在一个等价的 $\mu$-句子~\cite{bradfield2018mu}。
%因此，判定问题$\Muforget(\varphi, V ) \models^? \psi$规约成其对应的 $\mu$-自动机是否为空的问题。
	% Our goal is to reduce the emptiness problem for modal automata to  the same problem for alternating automata on binary trees. 
	%因此，困难属性直接来源于~\cite{bradfield2018mu,comon1997tree}。
	
	(ii) 在$\textsc{Exptime}$中. 可类似于(i)来证明。 
	
	$\textsc{Exptime}$-难.   $\psi \models \Muforget(\varphi, V)$  当且仅当$\neg \psi \vee \Muforget(\varphi, V)$是有效的。令$\psi \equiv \top$，$\top \models \Muforget(\varphi, V)$ 当且仅当$\Muforget(\varphi,V)$是有效的，当且仅当$\varphi$是有效的（或$V =\Var(\varphi)$且$\varphi$是可满足的）。判定$V$是否等于$\Var(\varphi)$能在$\varphi$大小的线性时间内完成。此外，判定$\varphi$是有效的（或可满足的）是 $\textsc{Exptime}$-完全的。因此原问题是$\textsc{Exptime}$-完全的。 
	
	(iii) 因为$\Muforget(\varphi, V) \models \Muforget(\psi, V)$当且仅当$\varphi \models \Muforget(\psi, V)$，所以这可类似(ii)来证明。
\end{proof}

与上面的几个推论问题类似，下面考虑这几个等价问题：Lang等人提出的“var-independence”和“var-equivalence”问题~\cite{DBLP:journals/jair/LangLM03}，及“Var-match”问题:
\begin{itemize}
	\item[(i)] $[$Var-independence$]$ 公式$\varphi$是否独立于原子命题的集合$V$，即$\Muforget(\varphi,V) \equiv \varphi$，
	\item[(ii)] $[$Var-match$]$  $\varphi$在$\psi$的原子命题上的约束与 $\psi$等价，即$\Muforget(\varphi, V) \equiv \psi$，
	\item[(iii)] $[$Var-equivalence$]$  $\varphi$和$\psi$在原子命题$V$上的约束是否等价，即$\Muforget(\varphi, V) \equiv \Muforget(\psi, V)$。
\end{itemize}
%对于 $\varphi$和 $\psi$，其原子命题上的约束是一样的。
% both equivalent problems and reasoning problems have the same constraints.
% In these problems, $\varphi$ and $\psi$ have the same constraints as those in reasoning problems.
%The following results are implications of Theorem\ref{thm:Ent}.

\begin{corollary}\label{chapter06:cor:equiv}
	给定$\mu$-句子$\varphi$和 $\psi$，$V$为原子命题的集合。则下面的判定问题为$\textsc{Exptime}$-完全的。
	\begin{itemize}
		\item[(i)] 判定 $\psi \equiv^?\Muforget(\varphi, V)$，
		\item[(ii)] 判定 $\Muforget(\varphi, V) \equiv^? \varphi$，
		\item[(iii)] 判定 $\Muforget(\varphi, V) \equiv^? \Muforget(\psi, V)$。
	\end{itemize}
\end{corollary}
\section{本章小结}\label{sec:chapter06-conclusion}

本章介绍了$\mu$-演算下的遗忘。$\mu$-演算是一种比$\CTL$表达能力强的逻辑系统，本章说明了$\mu$-演算下的遗忘是封闭的且与均匀插值是一对对偶概念。此外，本章也研究了$\mu$-演算下的代数属性，表明$\mu$-演算下的遗忘也具有分解性、切片性和同质性。表示性定理给出了遗忘与四条基本公设之间当且仅当的关系。最后，遗忘在模型检测和推理问题上的复杂性结果表明遗忘操作是很困难的，即指数时间的。
