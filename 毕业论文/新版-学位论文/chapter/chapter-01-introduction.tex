\chapter{绪论}\label{chapter01}
{\em 本章首先介绍研究的立项背景，分析保障系统正确的重要性，并阐述研究意义。其次，综述分析遗忘理论、最强必要（最弱充分）条件等关键技术的国内外研究动态，以及遗忘理论在形式化验证中的应用研究趋势。然后，围绕研究对象凝练出关键问题与目标。进一步，介绍本文的核心研究内容以及研究取得的主要成果。最后，给出具体章节组织安排。}
\section{研究背景与意义}
\subsection{研究背景}

形式化验证是一种广泛应用在硬件\cite{lam2007,lv2000,jani2007Verilog}和软件系统中\cite{yuan2008,gu2005}的有别于测试的、采用数学方法证明系统满足给定特性的验证（verification）技术。软件和硬件的缺陷会导致严重的后果，如表\ref{tab:systemEvents_1.1}中列出的几个重大事件。近年来，为了减少系统（尤其是像火箭发射系统和卫星发射系统等关键领域的系统）错误带来的损失，形式化方法的研究与应用越来越受到人们的重视。包括INTEL、AMD、IBM、NVIDIA、CADENCE、 Motorola、西门子和微软等在内的大型公司纷纷引入了形式化验证方法。与此同时，学术界也在形式化验证领域取得了突破性的成果，比如：剑桥大学进行了ARM6处理器的验证\cite{DBLP:conf/tphol/Fox03}，德国的Verisoft项目验证了一个一万行的操作系统内核\cite{DBLP:conf/sefm/DaumSS09}。

\begin{table}[htbp]
\caption{由系统故障引起的重大事件概览}
\label{tab:systemEvents_1.1}
\centering
\fontsize{10pt}{\baselineskip}\selectfont
\begin{tabular}{p{0.12\textwidth}p{0.35\textwidth}p{0.35\textwidth}}%
	\toprule
	\textbf{发生时间}&\textbf{事故事件（系统错误）}&\textbf{造成的损失}\\
	\midrule
    1991年 & 美国爱国者导弹系统舍入错误 & 28名士兵死亡、100人受伤等\\
	1996年 & 阿丽亚娜5型运载火箭因软件不同飞行条件下代码重用 & 导致其与其他卫星在瞬间灰飞烟灭\\
	1999年 & 火星探测器用错度量单位 & 引起探测器坠毁并造成了3.27亿美元的损失\\
	2011年 & 温州7.23动车信号设备在设计上存在严重的缺陷导致 &导致动车脱节脱轨、多人失去生命\\
	
\bottomrule
\end{tabular}
\end{table}

形式化验证有两种主要的验证方法：自动定理证明（Automated theorem proving）和模型检测（Model checking)。
在自动定理证明中，系统模型和规范（specification）被同一形式化语言分别描述为$\varphi_{imp}$和$\varphi_{spec}$，剩下的任务就是证明性质，如:$\varphi_{imp}\rto \varphi_{spec}$或$\varphi_{imp}\lrto\varphi_{spec}$。
常用的自动定理证明方式有基于归结（Resolution）\cite{DBLP:journals/jacm/Robinson65}和常用于模态逻辑的基于表推理（tableau）\cite{hughes1996new}的方法。
然而，在自动定理证明中寻找不变式（invariant）是一个相当困难的问题。
因此，为了避免像Hoare逻辑\cite{Hoare1969}、动态逻辑\cite{harel1979first}和分离逻辑\cite{DBLP:conf/lics/Reynolds02}在形式化验证中寻找不变式，Fangzhen Lin提出将一个程序（program）转换为一阶理论，
然后再使用一阶理论中的自动定理证明方法来验证\cite{DBLP:journals/ai/Lin16}。

形式化验证的模型检测首先由Clarke提出，并用于解决并发系统验证问题\cite{DBLP:conf/spin/Clarke08}。Clarke和Emerson在文章\cite{clarke1981design}中指出，在有限状态的并发系统中使用时态逻辑的推演系统（deductive system）中的公理和推理规则进行构造性证明（proof construction）的方法来证明该系统是否满足给定的规范是不必要的。因为在有限状态并发系统中，该并发系统可以被看作是一个Kripke结构$\Hm$，与此同时，一个规范被表示成一个逻辑公式$\varphi$。此时，该验证问题就变成检验一个Kripke结构是否满足该公式，即模型检测（$\Hm\models \varphi$）: 判断$\Hm$是否是$\varphi$的一个模型。

近年来，模型检测问题在知识表示与推理（KRR）领域的推进下取得了丰富的科研成果，例如：基于SAT的有界（bounded）模型检测\cite{DBLP:journals/ac/BiereCCSZ03}和基于OBDD的符号模型检测\cite{burch1992symbolic}已经使得模型检测问题在时间和空间效率上取得了很大的进步，在一定程度上缓解了其固有的状态空间爆炸问题。此外，大量优质的模型验证器（如：NuSMV\footnote{http://nusmv.fbk.eu/}、SPIN\footnote{http://spinroot.com/spin/whatispin.html}、Uppaal\footnote{http://www.uppaal.org/} 等）也相继发展起来，并且大部分的验证器都可以用来验证多种时态逻辑描述的公式。  

       
时态逻辑作为描述系统规范的形式化语言，它研究状态随时间变化的系统的逻辑特性。由于软件和硬件的运行的本质是状态变化的过程，所以时态逻辑在软件程序验证和硬件验证中应用得相当广泛。计算树逻辑（Computation Tree Logic, \CTL）是分支时态逻辑的一种，其模型检测是多项式时间可行的。然而，$\CTL$表达系统性质的表达能力不如$\mu$-演算（$\mu$-calculus），如：“某给定的系统中存在一条路径使得该路径上的第偶数个状态满足特定的性质”这一规范是不能用其他时态逻辑表示的\cite{DBLP:series/txtcs/Schneider04}。充分考虑这两种逻辑语言自身的特性，本文将要研究的描述规范的逻辑语言限制到$\CTL$和$\mu$-演算下。因此，本文所说的公式指$\CTL$（或$\mu$-演算）公式，即用来描述一个规范（或性质）的公式是$\CTL$（或$\mu$-演算）公式。

在实际应用中，对于给定的$\Hm\models \varphi$问题，当$\Hm$满足$\varphi$时一般的验证器都会返回“yes”以表示满足，当$\Hm$不满足$\varphi$时验证器会给出一个使得$\varphi$不被$\Hm$满足的负例。此时，\emph{使用什么样的信息对$\Hm$进行修正使得其满足给定的规范是一个重要的问题}。

从知识抽取（或“消除”）的角度来看。出于安全考虑，查看信息时需要将有的信息隐藏掉而只抽取关注的部分信息。
此外，随着时间的推移，由于某些原因使得系统的部分信息过时，此时就需要将这样的过时信息在不影响其他信息的情况下“消除”。
考虑如下示例：
\begin{example}[汽车制造企业模型]\label{car_manufacturing}
	一个汽车制造企业能够生产两种汽车：小轿车($se$)和跑车($sp$)。每隔一段时间，该企业都会做一个生产决策($d$)，即：合理的生产计划。
	刚开始的时候，该企业做出了具有三个选择的方案：（1）先生产足够的$se$，然后在生产$sp$；（2）先生产足够的$sp$，然后在生产$se$；（3）同时生产$se$和$sp$。
	这一过程可以由图~\ref{BVM}中的Kripke结构（带标志的状态转换图）$\Hm=(S,R,L)$形式化地展现出来，其中:
	\begin{itemize}
		\item $V=\{d,s, se, sp\}$为该工厂所需要考虑的原子命题的集合；
		\item $S=\{s_0,s_1,s_2,s_3,s_4\}$为状态空间；
		\item $R = \{(s_0, s_1), (s_1,s_2), (s_1,s_3), (s_1,s_4), (s_2,s_0), (s_3,s_0),(s_4,s_0)\}$为状态转换关系的集合；
		\item $L: S \rto 2^V$为标签函数，具体地：$L(s_0) = \{d\}$、$L(s_1) = \{s\}$、 $L(s_2)=\{se\}$、 $L(s_3) = \{sp\}$和$L(s_4) = \{se,sp\}$。
	\end{itemize}
	\begin{figure*}[ht]
		\centering
		\includegraphics[width=4cm]{NnewCar.png}\\
		\caption{汽车制造企业模型}\label{BVM}
	\end{figure*}

假定现在由于经济危机或者是环境需要，导致该企业不能再生产跑车。这意味这所有关于$sp$的规范和Kripke结构都不再需要考虑，因此应该“移除”掉。
\end{example}

日常生活中也有很多上述例子中的场景，如：商业交易过程、软件开发过程等~\cite{Baier:PMC:2008}。
但是对于给定原子命题的集合，\emph{从这些大型系统（或规范）中“移除”掉这些原子而保持与这些原子无关的性质是一个复杂的问题}。
此外，在这种情形下，两个重要的概念：最强必要条件（SNC）和最弱充分条件（WSC）问题也随之产生，其中SNC是指最一般的结论，WSC指最特殊的诱因。

基于上述存在的问题，本文在下面的研究意义部分给出对应的解决方案和其意义所在。

\subsection{研究意义}
最强后件（SP）和最弱前件（WP）（分别对应于上文提到的SNC和WSC）是形式化验证中的两个重要的概念，其不仅被用于汇编语言程序推理~\cite{legato2002weakest}和制定验证条件\cite{DBLP:journals/ipl/Leino05}，还被应用于形式化验证过程中的负例生成\cite{dailler2018instrumenting}和系统精化（refinement）\cite{woodcock1990refinement}。
当$\Hm\not \models \varphi$时，若知道某个性质$\psi$使得若$\Hm$按照此性质进行修改后得到的新模型$\Hm'$能满足$\varphi$，即$\psi$为使得$\Hm\models \varphi$成立的充分条件（$\Hm \models \psi\rto \varphi$）。
然而，现有的方法不能直接应用于计算当$\Hm$为不终止系统（如：反应式系统（reactive system））时使得“$\Hm\models \varphi$”为真的最强必要条件（SNC）和最弱充分条件（WSC）
（其详细原因将在下文指出）。此时，\emph{探索在$\Hm$下使得$\varphi$满足的定义在某个符号集合上的SNC和WSC将更进一步完善模型检测问题，
同时也为基于WSC的负例生成和精化提供了理论依据和新的计算方法。}

本文中将探索一种叫做\emph{遗忘}（forgetting）的方法来计算充分（必要）条件。正如下文将要说到的，遗忘理论作为知识表示与推理（KRR）中重要理论，具有较长的科研历史，且在许多逻辑中都有了较为成熟的研究。然而，在时序逻辑方面的研究目前还不成熟。因此，作为本文一个重要的研究意义，\emph{本文的研究将为时序逻辑下遗忘理论的研究提供一个理论框架。
与此同时，借助遗忘理论计算上述形式化验证问题中的充分（必要）条件，这架起了KRR与形式化验证的桥梁。}

\section{相关研究工作回顾}
\emph{遗忘（forgetting）}是一种重要的知识抽取工具，它具有均匀插值（uniform interpolation）和二阶量化消解（second-order quantifier elimination，SOQE）两种称呼。
在很长一段时间内，遗忘被用于描述逻辑中本体（ontology）摘要的提取、敏感信息的隐藏和软件工程中计算两个文件的逻辑差（logic differences）。此外，其也被用于包括信念更新（belief update）、修改（repair）、规划（planning）和知识独立性的其他领域。

{\em 反应式系统}是一种不终止的、与环境有着持续不断交互的系统，其应用广泛、种类繁多。本文探究如何使用遗忘计算反应式系统下的SNC（WSC），下面就与本文密切相关的反应式系统、遗忘理论和SNC（WSC）进行回顾。

%在规划中，遗忘主要用来计算其对应的后继状态公里所需要的SNC和WSC。下面就与本文密切相关的遗忘理论和SNC（WSC）进行详细的回顾。


\subsection{反应式系统}
随着应用程序在各个领域的应用，对其需求已经发生了重大变化，继而引起模式变化。
以前，一个大型的应用程序通常需要数十台服务器，如此高的代价换来的效果和维护成本不成正比：秒级的响应时间，但需要数小时的维护时间。
当前，移动和云端技术的成熟使应用程序不拘泥于以前的方式，被部署到了移动设备和具有多核心处理器的云端集群上。
用户对应用程序的响应时间要求从秒级变到毫秒级，且具有100\%的成功率， 而数据量也从之前的GB级扩展到现在的PB级。
原有的软件架构已经无法满足今天的需求。

要满足现有的要求，应用程序需要剧本以下特质：即时响应性（Responsive）、回弹性（Resilient）、弹性（Elastic）以及消息驱动（Message Driven）\footnote{https://www.reactivemanifesto.org/zh-CN}。
反应式系统是一种与环境有着持续不断交互的系统，具有不终止的性质~\cite{DBLP:series/txtcs/Schneider04}，它满足上述的几种要求，且从传统的静态模式逐步向动态、开放、自适应、服务化的软件系统演化~\cite{jian2012}。
反应式系统由来已久~\cite{DBLP:conf/nato/HarelP84,DBLP:books/sp/trends86/Pnueli86}，且种类繁多，如微处理器（microprocessor）、计算机操作系统（computer operating systems），航空交通管制系统（air traffic control systems）、车载电子设备（on-board avionics）以及其他嵌入式系统。

此外，反应式系统的应用非常广泛：上至航空电子等安全攸关的领域，下至生活息息相关的汽车电子。
安全攸关反应式系统的核心要求是：必须在指定时间期限内完成对外部事件的检测和目标事件的响应，否则会产生灾难性的后果~\cite{wangjuan2019}。
为了确保反应式系统的正确性和实时性，不同的方法被提出，包括：模型检查方法~\cite{DBLP:books/daglib/0007403,clarke1996model,DBLP:series/txtcs/Schneider04}、目标驱动的运行时需求建模框架~\cite{jian2012}、基于图模型的实时规则调度方法（graph-based real-time rule scheduling,简称GBRRS）~\cite{wangjuan2019}、SPARDL~\cite{wangzhen2012}和选择性测试方法~\cite{lishu2004}等。
%这些应用的核心为嵌入式周期控制系统（一种反应式系统），该系统的行为不仅与自身的定义和状态有关，还与控制软件所处的环境有关。
%\begin{itemize}
%	\item 即时响应性：只要有可能， 系统就会及时地做出响应。
%\end{itemize}

在上面的方法中，大都是验证（检测）给定的系统是否具有某种性质，而当系统不满足该性质时对如何寻找可靠的信息（充分条件）来对系统进行修改没有探讨。
反应式系统是一种不终止的系统，在本文中其被看作一个Kripke结构。基于此，本文探索如何计算该充分条件使得系统在该条件下满足给定的性质。




\subsection{遗忘理论}\label{chapter01:forgetting}
遗忘这一词源于Lin等人关于一阶逻辑（first-order logic， FOL）的工作~\cite{lin1994forget}，在此之前的研究中多提到的是均匀插值~\cite{visser1996uniform,konev2009forgetting}和SOQE~\cite{ackermann1935untersuchungen}。

在命题逻辑中（propositional logic，PL），从公式$\varphi$里遗忘掉一个原子命题$p$通常记为$\Forget(\varphi,\{p\})$，得到的结果为$\varphi[p/\bot] \vee \varphi[p/\top]$（其与$\exists p\varphi$等价），其中$\varphi[X/Y]$为将$\varphi$中$X$的全部出现替换为$Y$得到的结果。
%在Lin等人的文章中也将$\varphi[p/\bot] \vee \varphi[p/\top]$用$\exists p\varphi$来表示~\cite{lin1994forget}。
从公式$\varphi$中遗忘掉有限的原子命题集合$P$被定义如下：
\begin{alignat*}{2}
	&  \Forget(\varphi, \emptyset) = \varphi, \qquad \\ % \nonumber
	&  \Forget(\varphi, P \cup \{q\})  = \Forget(\Forget(\varphi, \{q\}), P).
	\nonumber
\end{alignat*}

在FOL中，遗忘通常被看为SOQE问题的一个实例。
特别地，从FOL公式$\varphi$中遗忘掉一个$n$-元谓词$P$得到的结果为一个二阶公式$\exists R \varphi[P/R]$~\cite{lin1994forget}。
从这个角度看来，遗忘就是找到一个与二阶公式$\exists R \varphi[P/R]$等价的一阶公式。
然而，二阶逻辑的表达能力是严格大于一阶逻辑的，因而可以容易得出FOL下的遗忘不是封闭的，也就是说从有的一阶公式中遗忘掉某些谓词得到的结果不可以用一阶公式来表示。
作为FOL的一个子类，描述逻辑公式的遗忘也不总是存在的~\cite{DBLP:journals/ai/KonevL0W13}，甚至对最基本的描述逻辑{\cal ALC}而言，遗忘的存在性问题都是不可判定的。
尽管如此，描述逻辑作为一种在语义网领域很重要的语言，其子类（包括{\cal ALCOHI}和{\cal ALCOIH}）中的遗忘通常被用来抽取视图（review）~\cite{Wang:AMAI:2010,DBLP:conf/ijcai/LutzW11,Konev:JAIR:2012,DBLP:conf/ijcai/ZhaoS17,DBLP:conf/aaai/ZhaoSWZF20}。

现有的研究一阶逻辑和描述逻辑下的遗忘的方法有基于归结（resolution）和基于Ackermann引理的方法~\cite{DBLP:books/daglib/0023036}。
其中基于归结的方法是一种基于子句的归结方法，归结规则是其基础。通常在这种方法中首先要把公式转换为其子句形式，然后再使用归结规则，最后将得到的子句集合中包含有要遗忘的谓词（原子命题）“移除”掉后得到的结果可能就为遗忘的结果（在后文中会详细介绍与本文相关的归结规则和转换规则）。
基于Ackermman引理的方法主要是直接或间接（扩展）使用下面的Ackermann引理得到的。
\begin{lemma}[引理 6.1~\cite{DBLP:books/daglib/0023036}]
	给定关系变元$X$和一阶公式$\alpha(\overline{x}, \overline{z})$和$\beta(X)$，其中$\overline{x}$和$\overline{z}$为普通变元构成的多元组、$\overline{x}$中变元的个数与$X$的参数个数相同、且$\alpha$中不包括$X$。
	\begin{itemize}
		\item 若$\beta(X)$关于$X$是正的，即：$X$在$\beta(X)$中的每次出现前面都有偶数个“$\neg$”符号，则：
		$$\exists X \{\forall \overline{x} [X(\overline{x}) \rto \alpha(\overline{x},\overline{z})] \wedge \beta(X)\} \equiv \beta(X)_{\alpha(\overline{x},\overline{z})}^{X(\overline{x})}\hbox{。}$$
		\item 若$\beta(X)$关于$X$是负的，即：$X$在$\beta(X)$中的每次出现前面都有奇数个“$\neg$”符号，则：
		$$\exists X \{\forall \overline{x} [ \alpha(\overline{x},\overline{z}) \rto X(\overline{x})] \wedge \beta(X)\} \equiv \beta(X)_{\alpha(\overline{x},\overline{z})}^{X(\overline{x})}\hbox{。}$$
	\end{itemize}
\end{lemma}



\emph{知识遗忘}（knowledge forgetting）在模态逻辑S5中首先被提出并被用于推理智能体的知识状态（知识或者信念）~\cite{Yan:AIJ:2009}。
模态逻辑中的遗忘与经典逻辑下的遗忘不同，因为模态逻辑系统中引入了模态词，此时就不能以简单的谓词（命题）替换的方式获取遗忘的结果，如：
\begin{example}\cite{Zhang2008Properties}
	令S5公式$\varphi=\MPK p \wedge \neg \MPK q \wedge \neg \MPK \neg q$，则如果使用命题逻辑下的计算方法得到的结果为$\varphi[q/\top] \vee \varphi[q/\bot]$。
	这显然是不正确的，因为在遗忘$q$之后智能体的知识库不应该变得不一致。
\end{example}
为此，新的计算方法和四个能精确描述知识遗忘的基本公设被给出，值得注意的是这四个条件与知识遗忘形成了“当且仅当”的关系。换句话说，当知道某一个公式满足那四个条件则该公式为遗忘的结果，当知道某一结果为遗忘结果时它一定满足那四个基本条件。
此外，模态一阶逻辑S5中的遗忘也得到了研究~\cite{Yongmei:IJCAI:2011}，Fang等人也讨论了关于多模态（multi-modal）$K_n$、 $D_n$、 $T_n$、$K45_n$、 $KD45_n$情形下遗忘的存在性~\cite{DBLP:journals/ai/FangLD19,wenximing2019}——这些逻辑里的遗忘总是存在的，其中$n$为智能体的个数。

均匀插值作为遗忘的一个对偶概念，这里有必要介绍一下模态逻辑系统的这一性质的研究现状。
S5、K和KD模态逻辑系统具有均匀插值性质~\cite{DBLP:journals/aml/Iemhoff19}，
而一些模态逻辑系统没有均匀插值性质，如：模态逻辑量化的S5~\cite{DBLP:journals/jsyml/Fine79}和K4、和S4及其扩展都没有均匀插值性质~\cite{DBLP:journals/ndjfl/Schumm86}，因而其遗忘也不是封闭的。
因此，在研究这些具有均匀插值性质的模态逻辑下的遗忘时可以借鉴S5系统下的遗忘方法，也可以参考K系统下的基于归结计算均匀插值的方法。
对于那些没有均匀插值的模态逻辑系统可以考虑模态逻辑下的Ackermann引理~\cite{DBLP:books/daglib/0023036}。


%此外，Feng等人也研究了S5下如

在非单调推理（non-monotonic reasoning）环境中，科研工作者们也从遗忘的基本条件的角度研究了
基于回答集语义的逻辑程序的遗忘，这些工作包括Zhang、Wang等人发表在AI和JAIR上的文章~\cite{DBLP:Zhang:AIJ2006,DBLP:journals/ai/EiterW08,Wong:PhD:Thesis,DBLP:journals/jair/WangZZZ14,wang2013forgetting,DBLP:journals/jair/Delgrande17,gonccalves2020limits}，Eiter、Gonccalves等人的综述~\cite{eiter2019brief,gonccalves2021forgetting}。


%应用
在现实生活中，遗忘有很多应用。下面列出几点：
\begin{itemize}
	\item 计算后继状态公理：在规划问题中，根据最强必要条件和最弱充分条件有利于求出后继状态公理\cite{DBLP:journals/jair/Lin03}。在该文章中，最强必要条件和最弱充分条件都用遗忘来计算；
	\item 信息隐藏：在有的关键领域，为实现隐私保护，敏感信息必须被隐藏。现有的方法包括基于本体\cite{DBLP:journals/ai/KonevL0W13}和基于DataSecOps的个人信息保护\cite{wangwen2021}，要做到隐私保护，只需要将那些敏感的概念（concept）和角色（role）符号隐藏（遗忘）就行了。值得注意的是个人信息保护涉及被遗忘权\cite{zhujia2020};
%	\item 计算逻辑差：
	\item 知识更新：在许多场景，知识不是一层不变的，随着时间或空间的推移，会有新的知识加入，如何用新加入的信息更新原有知识而保证知识库的一致性是知识更新需要解决的问题。此外，知识更新也需要满足一些基本条件，在这些基本条件中，Katsuno和Mendelzon提出的$(U1)$-$(U8)$较为常用，本文也使用这几个基本条件；
	\item 提取本体的概要：当一个本体工程师想要快速了解并测试一个本体的内容时，能事先快速地提取出该本体的概要是非常有用的。当一个本体含有很多无关信息时，这使得事半功倍;
	\item 遗忘在归并和逻辑独立性中也有着重要作用\cite{xudai2011}。
\end{itemize}







\subsection{SNC和WSC}


正如上文所说，WSC（SNC）对于软件工程中系统的形式化验证有着及其重要的作用。
一般说来，最强必要条件（SNC）是最一般的推论（the most general consequence），即：命题成立时能推出的最强的后件（the strongest post-condition, SP），SNC能够蕴涵所有的必要条件；最弱充分条件（WSC）是最特殊的诱因（the most specific abduction），即：使得命题成立的最弱的前提条件（the weakest precondition，WP），WSC能被所有的充分条件蕴涵。

特别地，给定一个程序（program）$S$和某一状态（state）的规范（specification）$Q$，则$S$关于$Q$的WSC是一个能够描述$S$初始状态的规范，其中$S$满足以下两个条件：（i） $S$必须终止，（ii）$S$执行完成后必须到达能满足$Q$的状态。Dijkstra提出了四条规则来计算这样的规范，程序语言里的四种语句（即：赋值语句（assignment rule）、顺序语句（sequence rule）、条件语句（conditional rule）和循环语句（loop rule））分别对应了这四种规则~\cite{DBLP:journals/cacm/Dijkstra75}。
此外，这两个概念还可用于系统精化~\cite{woodcock1990refinement}、模型检测中的负例产生~\cite{dailler2018instrumenting}、汇编语言程序的推理~\cite{legato2002weakest}和制定验证条件~\cite{DBLP:journals/ipl/Leino05}。
在上述计算WSC的方法中，有一个必须满足的要求是“$S$必须终止”，这就是上文中说到的当系统为反应式系统这类不终止系统时现有方法不能计算WSC的主要原因。


在知识表示与推理中，SNC和WSC为因果理论中后继状态公理的计算提供了一种方法~\cite{DBLP:journals/jair/Lin03}，且SNC和WSC都可以用遗忘来计算~\cite{DBLP:journals/ai/Lin01,DBLP:conf/ijcai/DohertyLS01}。
之后，SNC和WSC被扩展到FOL下，且用SOQE实现了SNC和WSC的计算~\cite{DBLP:conf/ijcai/DohertyLS01}。

这里对SNC和WSC的发展和应用只做了简单的概述，在背景知识部分再对其在命题逻辑和模态逻辑这两种情形进行详细介绍（包括其定义和算法）。






\section{研究目标及主要结果}

相关研究工作表明现存方法不能很好的解决反应式系统下的WSC（SNC）的求解。然而，WSC是一种进行系统修改的重要知识，寻求一种有效的求解方法有利于系统正确性的确保。
在知识表示与推理中，一种叫做遗忘的技术可以用于求解给定理论（公式）的WSC（SNC）。
但是，就如上面所述时序逻辑下的遗忘理论尚处于不成熟阶段，没有一个统一的理论框架。
此外，如何用遗忘来计算给定系统模型和性质的WSC（SNC）也是一个重要问题。

基于此，{\em 本文从遗忘理论的角度出发，研究反应式系统下SNC和WSC的计算方法，从而为计算不终止类系统下定义在某个符号集上的SNC和WSC提供了新的方法，架起形式化验证与KRR之间的桥梁。}
%特别地，本文将规范的描述语言限制到$\CTL$和$\mu$-演算下。
为了实现这一目标，本文\textbf{主要研究内容及结果}如下：

(1) {\em $\CTL$和$\mu$-演算的遗忘理论}

本文研究了$\CTL$中遗忘理论的方法和性质，特别是其遗忘结果的存在性、复杂性等，为探索用遗忘理论计算SNC和WSC奠定论基础。具体说来，遗忘理论具有削弱（Weakening，(W)）、正维持（Positive Persistence，(PP)）、负维持（Negative Persistence，(NP)）、无关性（Irrelevance，(IR)）等基本准则\cite{Yan:AIJ:2009}。本文探索$\CTL$和$\mu$-演算的遗忘理论的以上准则，并探讨其与存在性之间的关系。此外，本文研究了 $\CTL$和$\mu$-演算 中计算遗忘结果的方法，探讨了$\CTL$和$\mu$-演算与遗忘相关问题的复杂性结果，为研究计算SNC和WSC的性质、算法以及基本准则等作好铺垫。具体说来，有以下两点：
\begin{itemize}
	\item \textbf{$\CTL$的遗忘理论：}
	$\CTL$不具有均匀插值（uniform interpolation）性质\cite{Maksimova:JANCL:1991}，即：不存在一个算法使得对于任意的$\CTL$公式，其“遗忘”掉任意原子命题的集合得到的结果仍然是$\CTL$公式。在这种情况下，本文除了探讨了上述$\CTL$中遗忘的性质，还研究了$\CTL$子类的遗忘理论，特别是能保证其遗忘结果仍然是$\CTL$可表达的子类。在这些子类中，一个特殊的子类为约束$\CTL$（bunded \CTL）。在这种情形下，每个公式的模型是有限个数个，且每一个模型都能用一个$\CTL$公式表示。因此，其遗忘理论是封闭的。
	
	\item \textbf{$\mu$-演算的遗忘理论：}
	与$\CTL$不同，$\mu$-演算虽然表达能力比$\CTL$强，其可满足性问题也比$\CTL$的复杂，但是$\mu$-演算具有均匀插值性质\cite{d2006modal}。这意味着对于在任意的$\mu$-演算句子中“遗忘”掉任意的原子命题的集合得到的结果仍然是$\mu$-演算公式。本文给出了$\mu$-演算下遗忘理论的主要框架：包括上述遗忘理论的性质和计算遗忘的方法。
	特别地，表明了本文提出的$\mu$-演算下的遗忘定义与均匀插值是一对对偶概念，即本文中的遗忘具有的性质均匀插值也具有，这为研究均匀插值提供了另一种途径。
	此外，本文还说明了当$\mu$-公式为吸取$\mu$-公式时，计算遗忘理论可以在多项式时间内完成，这为$\mu$-演算下遗忘的计算提供了一种有效的方法。
\end{itemize}


(2) {\em $CTL$下遗忘理论的算法研究及实现}

基于上述研究结果，设计并实现了一个计算$\CTL$遗忘结果的原型系统，并从实验角度研究其计算代价以启发快速的计算遗忘结果的算法。
具体说来，本文给出了一种基于归结的计算$\CTL$遗忘的算法，并使用Prolog实现了该算法。
此外，对于约束$\CTL$的情形，本文也提出了一种基于模型的算法。

(3) {\em 遗忘理论在形式化验证和知识更新中的应用}

给出了使用遗忘计算给定有限系统模型的SNC和WSC的方法。如上所述，一个有限的系统模型能够被一个$\CTL$公式描述，因而可以使用遗忘计算其SNC和WSC。
此外，知识更新是一种使用新发现的性质更新已有理论的技术，本文探讨了如何使用遗忘更新$\CTL$和$\mu$-演算下的知识。
表明了使用遗忘定义的知识更新满足现有的知识更新的八条准则。

~\\
针对上述几个内容，解决了以下3个\textbf{关键问题}：

(1) {\em $\CTL$的遗忘什么情形下存在？如何计算遗忘？}

$\CTL$是一种分支时序逻辑，已有文献表明$\CTL$不具有均匀插值性质。与此同时，$\CTL$还引入了时态算子（temporal operator）。在此情形下，研究$\CTL$的遗忘就不能像已有的经典命题逻辑和模态逻辑S5那样，因为遗忘与均匀插值是一对对偶概念，即：它们可以互相证明彼此的存在性。为此，本文深度刨析现存的归结规则，提出了一种基于归结的计算遗忘的方法。该方法表明，当所有在转换为$\CTL$标准形式过程中引入的新的原子命题都被“消除”掉时，使用这一方法得到的结果即为遗忘的结果，即：这一方法是可靠的。
尽管$\CTL$下的遗忘不是封闭的，但是本文给出：当被归结的原子命题只能同时出现在同一模态词下的命题公式里时，遗忘总是存在的。

此外，考虑到现实生活中有的情形下只需要考虑有限模型，所以本文研究了约束$\CTL$下的遗忘理论。研究表明，这种情况下的遗忘结果可以由有限个模型的特征公式（一种$\CTL$公式）的吸取来表示，从而说明了这种情形下的遗忘是封闭（存在）的。

(2) {\em 遗忘理论与反应式系统的SNC和WSC的关系}

在经典命题逻辑和一阶逻辑中，遗忘理论与SNC和WSC的关系分别已经被Lin 和 Doherty等人分别提出~\cite{DBLP:journals/ai/Lin01,DBLP:conf/ijcai/DohertyLS01}。特别地，经典命题逻辑中的SNC和WSC被用于规划问题中的后继状态公理的计算。这里所说的SNC和WSC都是在给定的命题公式或一阶公式下的。本文给出，当给定一个有限反应式系统（Kripke structure）时，将该系统表示为其特征公式时就可使用
上述所说的$\CTL$和$\mu$-演算的遗忘理论计算SNC和WSC。



(3) {\em $CTL$和$\mu$-演算的遗忘在推理问题上的复杂性}

计算复杂性理论致力于将可计算问题根据它们本身的复杂性分类。研究表明，在经典命题逻辑中：CNF（Conjunctive normal form）公式的遗忘的推理问题最难是$\Pi_2^P$-完全的，DNF（Disjunctive normal form）公式的遗忘的推理问题是co-NP-完全的；在模态逻辑S5中，遗忘的模型检测问题是NP-完全的，对应的推理问题是$\Pi_2^P$-完全的。基于此，本文从现有复杂性结果和自动机理论研究$\CTL$和$\mu$-演算的遗忘在模型检测和推理问题上的复杂性。
研究表明$\mu$-演算下关于遗忘的模型检测是$\textsc{Exptime}$的，推理问题的复杂性都是$\textsc{Exptime}$-完全的。
而$\CTL$下关于遗忘的模型检测：当只考虑特殊段$\CTL_{\ALL \FUTURE}$（公式中只包括时态算子$\ALL \FUTURE$）时，其模型检测的复杂性为\textsc{NP}-完全的，而有的推理问题的复杂性再co-$\textsc{NP}$-完全的和$\Pi_2^{\textsc{P}}$-完全的之间。








\section{论文组织结构}
本文研究了计算树逻辑和$\mu$-演算下的遗忘理论，并探讨如何使用遗忘技术来计算SNC（WSC）和知识更新。全文共分为九章，组织结构如图\ref{fig:chapter1-research-structure}所示，各章节内容的具体安排如下：


\begin{figure}[htbp]
	\centering
	\includegraphics[width = 0.7\linewidth]{chapter01/zuzhi.png}
	\caption{本文的章节内容组织结构图}
	\label{fig:chapter1-research-structure}
\end{figure}

第\ref{chapter01}章为\textit{绪论}，首先阐述了本文的研究背景及意义，并分析给出了存在的问题，凝练出本文研究需要解决的关键问题。基于上述分析，阐述了本文的研究内容和研究取得的主要成果。最后给出了本文的章节组织结构安排。


第\ref{chapter02}章为 {\em 背景知识}，介绍了本文研究所涉及逻辑语言的语法语义及相关技术。首先，给出了经典命题逻辑下解释（赋值）的定义，并基于此描述了解释本文研究的语言的模型结构——Kripke结构。
在解释清楚语言所依赖的模型结构之后，本章给出$\CTL$和$\mu$-演算的语法和语义。
最后，除了最强必要条件和最弱充分条件在经典逻辑和模态逻辑S5下的研究，本章还介绍了与上述逻辑语言密切相关的两个技术：遗忘和$\CTL$下的归结。



第\ref{chapter03}章 {\em 给出$\CTL$下遗忘的定义及其基本性质}。首先，给出原子命题集合上模型间互模拟的定义，并介绍这一定义的基本属性；其次，根据互模拟来定义$\CTL$下的遗忘，并研究遗忘的属性，包括表达性属性（representation theory）和复杂性结果等。此外，本章还指出$\CTL$下的遗忘是不封闭的，即存在有的公式的遗忘的结果不能用$\CTL$来表示。



第\ref{chapter04}章 为{\em 基于归结的$\CTL$遗忘计算}。基于第\ref{chapter02}章的归结规则，本章探讨如何使用该归结系统计算$\CTL$下的遗忘。首先，将$\CTL$公式转换为归结规则需要的子句形式——$\CTLsnf$子句（后文详细介绍）；其次，使用归结规则计算所有可能的需要遗忘的原子命题上的归结结果；随后，移除那些包含要遗忘的原子命题的子句，并给出一种一般化的Ackermann引理消除一些新引入的原子命题；最后，将得到的结果转换成$\CTL$公式。此外，基于上述过程提出计算$\CTL$下的遗忘的算法，并分析该算法的时间和空间复杂性。

第\ref{chapter05}章 为{\em 约束$\CTL$下的遗忘}。在第\ref{chapter03}章所说，$\CTL$下的遗忘不是封闭的，因此在本章探讨了约束$\CTL$遗忘是封闭的情形。为此，本章提出了一种约束的互模拟，并给出给定深度的计算树在给定原子命题集合下的特征公式，继而给出有限情况下Kripke结构在给定原子命题集合下的特征公式。最后说明约束情形下$\CTL$公式的遗忘结果总是$\CTL$公式可表达的。




第\ref{chapter06}章 为{\em $\mu$-演算下的遗忘}。$\mu$-演算是一种表达能力比$\CTL$强的时序逻辑，其具有均匀插值性质。本章给出$\mu$-演算下遗忘的定义和基本属性，包括模块性、交换性及同质性。此外，探讨了$\mu$-演算下的遗忘是封闭的，且对任意吸取$\mu$-公式的遗忘可以在多项式时间内计算出来。
最后，给出$\mu$-演算下关于遗忘算子的模型检测和推理问题的复杂性结果。



第\ref{chapter07}章 为\textit{遗忘理论的应用}。讲述如何将遗忘应用于计算SNC（WSC）和定义知识更新。
此时，有限状态的反应式系统模型的WSC（SNC）可以通过遗忘来计算，且通过遗忘定义的知识更新满足Katsuno等人提出的知识更新应该满足的基本准则。
%在这种情形下将公式的模型限制到有限状态空间，组成公式的原子命题也是有限的。经过

第\ref{chapter08}章 为\textit{实验结果}。给出基于归结的算法实现模型的实验结果及分析。


第\ref{chapter09}章为\textit{总结与展望}。首先总结了本文的研究工作，进一步，展望了未来研究工作的方向和重点。
