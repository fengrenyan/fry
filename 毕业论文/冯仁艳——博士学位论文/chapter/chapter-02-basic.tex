\chapter{Kripke结构、时序逻辑、模型检测以及遗忘理论}\label{chapter02}

{\em 本章主要介绍本文用到的符号、术语以及逻辑理论基础，包括：Kripke结构、时序逻辑（尤其是计算树逻辑（CTL）和$\mu$-演算）、模型检测和遗忘理论。首先，介绍解释时序逻辑语言所需的模型结构，即Kripke结构。其次，主要介绍时序逻辑中本文探讨的计算树逻辑和$\mu$-演算。为了更加明确本文的研究动机，本章将详细介绍模型检测的基本概念和一些主要的性质。此外，遗忘理论是本文的研究重点，其概念、性质及在各个研究领域的研究和应用情况将会被当作本章的重点详细介绍。

为了方便，本文将命题变量（也叫原子命题）的集合记作$\cal A$，$V\subseteq {\cal A}$ 是$\cal A$的子集。此为，规定$\overline{V}$是$V$在${\cal A}$上的补，也即是$\overline{V}={\cal A}-V$。}
%{\em 围绕差分隐私应用中存在的隐私与数据可用性之间的权衡问题，本文以隐私信息度量为基础，试图从均衡优化的角度提供一种解决方案。为了更好的阐述后续的研究内容，本章首先介绍本文工作所需的基本模型与定义，包括隐私定义、差分隐私模型的形式化定义、Shannon信息论的基本通信模型及信息熵的概念。随后，介绍信息论、优化理论与对策博弈的基础知识，并以此为基础介绍了差分隐私均衡优化主要研究问题的描述及定义。本章阐述的内容主要为后续章节的具体研究奠定基础。}

\section{Kripke结构}
Kripke结构作为一种表示转换系统（transition system）的数学模型，在理论计算机科学领域有着广泛的应用，尤其是作为解释时序逻辑公式的模型结构。

\subsection{真假赋值和K-解释}
经典命题语言${\cal L}^p$由以下三类符号构成：
\begin{itemize}
	\item 命题符号：一般用小写拉丁字母$p$，$q$，$r$，$\dots$来表示，且这些命题符号来源于$\Ha$；
	\item 联结符号：$\neg$（否定），$\wedge$（合取），$\vee$（吸取），$\rto$（蕴涵），$\lrto$（等值于）；
	\item 标点符号：(（左括号），)（右括号）。
\end{itemize}
%命题符号：一般用小写拉丁字母$p$，$q$，$r$，$\dots$来表示，且这些命题符号来源于$\Ha$；
%连接符号：$\neg$（否定），$\wedge$（合取），$\vee$（吸取），$\rto$（蕴涵），$\lrto$（等值于）；
%标点符号：(（左括号），)（右括号）。

${\cal L}^p$的原子公式的集合和公式的集合分别记作$Atom({\cal L}^p)$和${\cal F}({\cal L}^p)$。其中，$Atom({\cal L}^p)$是命题符号的集合，且$\varphi\in {\cal F}({\cal L}^p)$当且仅当它能由（有限次使用）以下的三条规则生成\cite{luzhongwan1989}：
\begin{itemize}
	\item 如果$\varphi\in Atom({\cal L}^p)$，则$\varphi \in {\cal F}({\cal L}^p)$。
	\item 如果$\varphi \in {\cal F}({\cal L}^p)$，则$(\neg \varphi)\in {\cal F}({\cal L}^p)$。
	\item 如果$\varphi$，$\varphi'\in {\cal F}({\cal L}^p)$，则$(\varphi * \varphi')\in {\cal F}({\cal L}^p)$。其中，$*\in \{\wedge,\vee, \rto, \lrto\}$。
\end{itemize}
此外，也称“ture”和“false”为原子公式，分别记为“$\top$”和“$\bot$”。原子命题或其否定称为\emph{文字}，有限个文字的吸取称为\emph{子句}。

\begin{example}\label{exp:pro:form}
	下面几个字符串为${\cal L}^p$的公式：
	\begin{itemize}
		\item $(q \vee p)$；
		\item $(((\neg p)\lrto(q\vee r))\rto(r \wedge p))$。
	\end{itemize}
	而字符串$p\wedge \vee q$不属于集合$\varphi\in {\cal F}({\cal L}^p)$。
\end{example}


为了方便，称${\cal L}^p$的公式为\emph{命题公式}（在不引起歧义的情况下也称之为\emph{公式}）。此外，规定联结符号的优先级有助于简化公式（省略掉冗余的标点符号）。为此，规定在下面的序列中，每个左边的联结符号优先于右边的联结符号。
\[
\neg \qquad \wedge \qquad \vee \qquad \rto \qquad \lrto
\]
此时，例~\ref{exp:pro:form}中的公式$(((\neg p)\lrto(q\vee r))\rto(r \wedge p))$就可写为$(\neg p \lrto q \vee r) \rto r \wedge p$。当然，为了看起来方便，有的括号可以不必省略。

在讨论了命题公式的语法结构之后，接下来将讨论其语义解释。

\begin{definition}[真假赋值]\label{def:pro:interp}
	真假赋值是以所有命题符号的集为定义域，以真假值的集$\{0,1\}$为值域的函数$v:{\cal A}\rto \{0,1\}$。
\end{definition}
为了方便，后文中也将$\top$代表$1$，$\bot$代表$0$（此时真假赋值为$v:\Ha \rto \{\bot, \top\}$），且满足对任意的真假赋值$v$都有$\top^v=1$和$\bot^v=0$。由该定义可知，一个真假赋值要同时给${\cal A}$中的所有命题符号指派一个真假值，所以真假赋值的个数为$2^{|{\cal A}|}$。真假赋值$v$给公式$\varphi$指派的值记作$\varphi^v$，可形式化定义为如下：
\begin{definition}[公式的真假值]\label{def:pro:vformula}
	真假赋值$v$给公式指派的真假值递归定义如下：
	\begin{itemize}
		\item $p^v\in \{\bot,\top\}$，其中$p\in\Ha$。
		\item $(\neg \varphi)^v=\left\{
		\begin{array}{ll}
			\top, \qquad \hbox{如果$\varphi^v=\top$；} \\
			\bot,  \qquad  \hbox{否则。}
		\end{array}
		\right.$
		\item $(\varphi \wedge \psi)^v=\left\{
		\begin{array}{ll}
			\top, \qquad \hbox{如果$\varphi^v=\psi^v=\top$；} \\
			\bot,  \qquad  \hbox{否则。}
		\end{array}
		\right.$
		\item $(\varphi \vee \psi)^v=\left\{
		\begin{array}{ll}
			\top, \qquad \hbox{如果$\varphi^v=\top$或$\psi^v=\top$；} \\
			\bot,  \qquad  \hbox{否则。}
		\end{array}
		\right.$
		\item $(\varphi \rto \psi)^v=\left\{
		\begin{array}{ll}
			\top, \qquad \hbox{如果$\varphi^v=\bot$或$\psi^v=\top$；} \\
			\bot,  \qquad  \hbox{否则。}
		\end{array}
		\right.$
		\item $(\varphi \lrto \psi)^v=\left\{
		\begin{array}{ll}
			\top, \qquad \hbox{如果$\varphi^v=\psi^v$；} \\
			\bot,  \qquad  \hbox{否则。}
		\end{array}
		\right.$
	\end{itemize}
\end{definition}
对于任意的命题公式$\varphi$和真假赋值$v$，当$\varphi^v=\top$时，称$v$是公式$\varphi$的一个模型，也可以记为$v \models \varphi$，读作$v$满足$\varphi$。一般地，当存在一个真假赋值$v$使得$v\models \varphi$，则称公式$\varphi$是\emph{可满足的}。如果$\varphi$是可满足的，且$\neg \varphi$是不可满足的，则称$\varphi$是\emph{有效的}。

值得注意的是，命题逻辑的语义也可定义在“解释（interpretation）”上。一个\emph{解释}$I$是$\Ha$的子集。除了对原子命题$p\in \Ha$，$I$对公式的解释如真假赋值一样。在解释原子命题$p\in \Ha$上，$p^I$为真当且仅当$p\in I$。模型和可满足的定义与真假赋值的类似。

模态逻辑是经典逻辑的扩充，它是经典逻辑中引进“必然”和“可能”这两种模态词得到的。如上所述，命题的真假值只有两种，命题是真的（1）或是假的（0）。而在模态逻辑中，把命题
区分为必然真的命题和并非必然真的命题，把假命题区分为必然假的和并非必然假的命题。对于任何命题$\varphi$，可以有两种模态命题：“$\varphi$是必然的”和“$\varphi$是可能的”。值得注意的是，时序逻辑也是模态逻辑的一种\cite{gabbay2008second}。尽管如此，本文在说模态逻辑的时候通常指不带有时序操作符的情况，说时序逻辑时指带有时序操作符的情况。

本文所说的模态逻辑为命题单模态逻辑（propositional mono-modal logic）。模态公式的集合${\cal F}^{\Hm}$是包含“$\top$”和“$\bot$”的满足如下条件的最小集：
\begin{itemize}
	\item $\Ha \subseteq {\cal F}^{\Hm}$；
	\item 如果$\varphi \in {\cal F}^{\Hm}$，则$(\neg \varphi)$，$(\MPK \varphi)\in {\cal F}^{\Hm}$；
	\item 如果$\varphi$，$\psi\in {\cal F}^{\Hm}$，则$(\varphi * \psi)\in {\cal F}^{\Hm}$，其中$*\in \{\wedge,\vee, \rto, \lrto\}$。
\end{itemize}
令$\MPB = \neg \MPK \neg$，则$\MPB \varphi \in {\cal F}^{\Hm}$。其中，$\MPK$和$\MPB$叫做模态符号，分别表示“必然”和“可能”。

\emph{可能世界语义}（或\emph{Kripke语义}）是标准的命题模态逻辑语义\cite{kripke1963semantical}。Kripke语义是定义在Kripke结构上的，一个Kripke结构是一个三元组$(S,R,L)$（下一节中将详细介绍）。
其中，$S$是状态的非空集合，$R\subseteq R \times R$是可达性关系。特别地，当$R$是一个等价关系的时候（模态逻辑S5中），一个Kripke结构可以写成一个二元组$\tuple{W,w}$，其中$W$是状态的非空集合，$w$是$W$中的元素，每个状态是原子命题的集合。此时，称$\Hm=\tuple{W,w}$为一个$\MPK$-\emph{解释}（$\MPK$-interpretation）\cite{zhang2009knowledge}。

%$\MPK-$解释和${\cal F}^{\Hm}$种公式的可满足关系被归纳定义如下：
\begin{definition}\label{def:s5:interp}
	给定一个$\MPK$-解释$\Hm=\tuple{W,w}$，其与${\cal F}^{\Hm}$中的公式的可满足关系被归纳地定义为：
	\begin{itemize}
		\item $\Hm \not \models \bot$，$\Hm \models \top$；
		\item $\Hm \models p$当且仅当$p\in w$，其中$p\in \Ha$；
		\item $\Hm \models \neg \varphi$当且仅当$\Hm \not \models \varphi$；
		\item $\Hm \models \varphi \supset \psi$当且仅当$\Hm \not \models \varphi$或$\Hm \models \psi$；
		\item $\Hm \models \MPK \varphi$当且仅当$\forall w'\in W$有$\tuple{W, w'}\models \varphi$。
	\end{itemize}
\end{definition}

$\Hm=\tuple{W,w}$称为公式$\varphi$的$\MPK$-\emph{模型}（$\MPK$-model），当且仅当$\Hm \models \varphi$。此外，如果存在一个$\Hm=\tuple{W,w}$使得公式$\Hm\models \varphi$，则称公式$\varphi$是可满足的。如果$\Hm\models \varphi$对于所有的$\Hm=\tuple{W,w}$都成立，则称$\varphi$是有效的。


\subsection{Kripke结构的定义及相关术语}
通常一个转换系统（transition system）能够被抽象为一个Kripke结构\cite{Baier:PMC:2008}。如上文所说，一个Kripke结构是一个三元组$\Hm=(S,R,L)$，其中：
\begin{itemize}
	\item $S$是状态的非空集合；
	\item $R \subseteq S \times S$是状态转换函数；
	\item $L:S\rto 2^{\Ha}$是一个标签函数。
\end{itemize}
在本文中，要求$R$是一个串行关系（serial relation），也即是对于$S$中的任意元素$s$，都存在$S$中的一个元素$s'$使得$(s,s')\in R$。

给定一个Kripke结构$\Hm=(S,R,L)$，$\Hm$上的一条\emph{路径}是一个无限的状态序列$\pi=(s_0,s_1,\dots)$且满足对于任意的$j\ge 0$都有$(s_j,s_{j+1})\in R$，路径上的状态$s$被记为$s\in \pi$。当给路径$\pi$引入一个状态$s$作为下标，记为$\pi_s$，则称该路径是起点为该状态$s$的一条路径。如果对于$\Hm$中的任意状态$s'$，都有一条以$s$为起点的路径$\pi_{s}$使得$s'\in \pi_{s}$，那么称状态$s$为一个\emph{初始状态}。给定$s_0$为$\Hm$中的一个初始状态，为了容易看出该初始状态，将该Kripke结构写为四元组$(S,R,L,s_0)$，并称该结构为\emph{初始结构}以区分于原来的三元组。

\emph{树}是一种只有一个根节点（没有其他节点指向且可达于其他节点的节点）无环图。
给定一个初始结构$\Hm=(S,R,L,s_0)$和一个状态$s\in S$，定义在$\Hm$上以$s$为根节点的深度为为$n$（$n\ge 0$）的\emph{计算树}$\Tr_n^{\Hm}(s)$被递归定义如下\cite{browne1988characterizing}：
\begin{itemize}
	\item $\Tr_0^{\Hm}(s)$ 是只有一个节点$s$（其标签为$L(s)$）树。
	\item $\Tr_{n+1}^{\Hm}(s)$是以$s$为根节点（标签为$L(s)$）的树，并且满足若$(s,s')\in R$，则节点$s$有一棵子树$\Tr_{n}^{\Hm}(s')$。
\end{itemize}
%深度为$n$的\emph{计算树}$\Tr_n^{\Hm}(s)$是定义在初始结构$\Hm=(S,R,L,s_0)$和状态$s\in S$上的一个分支结构

一个初始结构$\Hm=(S,R,L,s_0)$和一个状态$s\in S$构成一个$\MPK$-\emph{结构}（或$\MPK$-解释），写作${\cal K}=(\Hm,s)$。
在$\MPK$-结构${\cal K}=(\Hm,s)$中，若$s=s_0$，则称该$\MPK$-结构为\emph{初始$\MPK$-结构}，此时有${\cal K}=(\Hm,s_0)$。



\section{时序逻辑}
时序逻辑是一种描述系统规范的形式化语言，它研究状态随时间变化的系统的逻辑特性。由于软件和硬件的运行的本质是状态变化的过程，所以时态逻辑在软件程序验证和硬件验证中应用得相当广泛。计算树逻辑（Computation Tree Logic, $\CTL$）是分支时态逻辑的一种，其模型检测是多项式时间可行的。然而，$\CTL$表达系统性质的表达能力不如$\mu$-演算（$\mu$-calculus），如：“某给定的系统中存在一条路径使得该路径上的第偶数个状态满足特定的性质”这一规范是不能用其他时态逻辑表示的[18]。充分考虑这两种逻辑语言自身的特性，本节主要介绍$\CTL$和$\mu$-演算。因此，本文所说的公式指$\CTL$（或$\mu$-演算）公式，即用来描述一个规范（或性质）的公式是$\CTL$（或$\mu$-演算）公式。

\subsection{计算树逻辑（\CTL）}
$\CTL$由Clark和Emerson等人于1986年提出\cite{DBLP:journals/toplas/ClarkeES86}。$\CTL$的语言${\cal L}$由下面的几类符号构成：
\begin{itemize}
	\item 原子命题的集合$\Ha$；
	\item 常量符号：$\top$和$\bot$，分别表示“真”和“假”；
	\item 联结符号：$\vee$和$\neg$，分别表示“吸取”和“否定”；
	\item 路径量词：$\ALL$和$\EXIST$，分别表示“所有”和“存在”；
	\item 时序操作符：$\NEXT$、$\FUTURE$、$\GLOBAL$、$\UNTILL$和$\UNLESS$，分别表示“下一个状态”、“将来某一个状态”、“将来所有状态”、“直到”和“除非”；
	\item 标点符号：“(”和“)”。
\end{itemize}
$\CTL$的时序算子是路径量词和时序操作符的组合（路径量词在前，时序操作符在后），如：$\ALL \NEXT$，$\EXIST \NEXT$， $\ALL \FUTURE$等。
与经典命题逻辑一样，给联结符号规定优先级，有时候会带来意想不到的方便。$\CTL$中的联结符号的优先级如下序列所示，每个左边的联结符号优先于右边的联结符号：
\[
\neg \quad \EXIST\FUTURE \quad \EXIST\GLOBAL \quad \ALL\NEXT \quad \ALL\FUTURE \quad \ALL\GLOBAL \quad \wedge \quad \vee \quad \EXIST\UNTILL \quad \EXIST\UNLESS \quad \ALL\UNLESS \quad \rto
\]

因此，语言$\cal L$的\emph{存在范式(existential normal form, ENF)}可以用巴科斯范式递归定义如下：
\begin{equation}\label{def:CTL:formulas}
	\phi ::=  \bot \mid \top \mid p \mid\neg\phi \mid \phi\lor\phi \mid
	\EXIST \NEXT \phi \mid
	\EXIST \GLOBAL \phi \mid
	\EXIST (\phi\ \UNTILL\ \phi)
\end{equation}
其中，$p\in \Ha$。$\cal L$中其他形式的公式可以通过下面的定义（使用上述定义中(\ref{def:CTL:formulas})的形式）得到：
\begin{alignat}{2}
	 \varphi \wedge \psi& \ \overset{def}{=}\ \neg (\neg \varphi \vee \neg \psi)\\
	 \varphi \rto \psi& \ \overset{def}{=}\ \neg \varphi \vee \psi\\
	 \ALL(\varphi \UNTILL \psi)& \ \overset{def}{=}\ \neg\EXIST(\neg \psi \UNTILL(\neg \varphi \wedge \neg \psi)) \wedge \neg \EXIST \GLOBAL \neg \psi\\
	 \ALL(\varphi \UNLESS \psi)& \ \overset{def}{=}\  \neg\EXIST((\varphi \wedge \neg \psi) \UNTILL (\neg \varphi \wedge \neg \psi))\\
	 \EXIST(\varphi \UNLESS \psi)& \ \overset{def}{=}\  \neg\ALL((\varphi \wedge \neg \psi) \UNTILL (\neg \varphi \wedge \neg \psi))\\
	 \ALL\FUTURE \varphi& \ \overset{def}{=}\ 	\ALL(\top \UNTILL \psi)\\
	 \EXIST\FUTURE \varphi& \ \overset{def}{=}\ \EXIST(\top \UNTILL \psi)\\
	 \ALL \NEXT \varphi& \ \overset{def}{=}\  \neg \EXIST \NEXT \neg \varphi\\
	 \ALL \GLOBAL \varphi& \ \overset{def}{=}\  \neg \EXIST \FUTURE \neg \varphi
\end{alignat}

此外，对于给定的公式$\varphi$，其否定范式（negation normal form, NNF）是将否定联结词“$\neg$”的出现通过上述定义变化到只出现在原子命题之前的形式。

$\CTL$的语义定义在Kripke结构上，可以严格地描述如下。
\begin{definition}[$\CTL$的语义]\label{def:ctl:semantic}
	给定$\CTL$公式$\varphi$，初始结构$\Hm=(S,R,L,s_0)$和状态$s\in S$。$(\Hm,s)$与$\varphi$之间的可满足关系$(\Hm,s)\models \varphi$定义如下：
	\begin{itemize}
		\item $(\Hm,s) \not \models \bot$且$(\Hm, s) \models \top$；
		\item $(\Hm,s)\models p$ 当且仅当$p\in L(s)$；
		\item $(\Hm,s) \models \varphi_1 \vee \varphi_2$当且仅当$(\Hm,s)\models \varphi_1$或$(\Hm,s)\models \varphi_2$；
		\item $(\Hm,s)\models \neg \varphi$当且仅当$(\Hm,s)\not \models \varphi$；
		\item $(\Hm,s)\models \EXIST\NEXT \varphi$当且仅当存在$S$中的一个状态$s_1$，使得$(s,s_1)\in R$且$(\Hm,s_1)\models \varphi$；
		\item $(\Hm,s)\models \EXIST\GLOBAL\varphi$当且仅当存在$\Hm$上的一条路径$\pi_s=(s_1=s, s_2,\dots)$，使得对每一个$i\ge 1$都有$(\Hm,s_i)\models \varphi$；
		\item $(\Hm,s)\models \EXIST(\varphi \UNTILL \psi)$当且仅当存在$\Hm$上的一条路径$\pi_s=(s_1=s, s_2,\dots)$，使得对某一个$i\ge 1$有$(\Hm,s_i)\models \psi$，同时对任意的$1\leq j < i$有$(\Hm,s_j)\models \varphi$。
	\end{itemize}
\end{definition}

%\begin{proposition}
%	令$\varphi_0 \wedge \ALL\FUTURE\varphi_1 \wedge \ALL\GLOBAL\varphi_2$是一个$\CTL$公式，$p$是一个原子命题，其中$\varphi_i$($i=0,1,2$)为命题公式，则：
%	\[
%	\CTLforget(\varphi_0 \wedge \ALL\FUTURE\varphi_1 \wedge \ALL\GLOBAL\varphi_2,\{p\}) \equiv \Forget(\varphi_0) \wedge \ALL\GLOBAL(\Forget(\varphi_2,\{p\})) \wedge \ALL\FUTURE(\Forget(\varphi_1 \wedge \varphi_2, \{p\})).
%	\]
%\end{proposition}

与Browne和Bolotov等人的工作类似，本文只将初始$\MPK$-结构作为模型的候选项\cite{browne1988characterizing,Bolotov:1999:JETAI}。换句话说，对于给定的$\MPK$-结构$(\Hm,s)$和$\CTL$公式$\varphi$，如果$(\Hm,s)\models \varphi$且$s = s_0$，则称$(\Hm,s)$为公式$\varphi$的一个\emph{模型}。更清楚地说，对于给定的初始$\MPK$-结构${\cal K}=(\Hm,s_0)$，如果${\cal K} \models \varphi$，则称$\cal K$是$\varphi$的一个模型。

为了符号的统一，这里列出文中出现的一些记号的含义。给定公式$\varphi$，公式的所有模型构成的集合记为$\Mod(\varphi)$。此时就很容易定义公式的可满足性，即：如果$\Mod(\varphi)\not = \emptyset$，则称$\varphi$是\emph{可满足}的。给定两个公式$\varphi_1$和$\varphi_2$，若$\Mod(\varphi_1)\subseteq \Mod(\varphi_2)$，则称$\varphi_1$\emph{逻辑地蕴涵}$\varphi_2$，记为$\varphi_1\models \varphi_2$。特别地，当$\varphi_1\models \varphi_2$且$\varphi_2\models \varphi_1$时，即$\Mod(\varphi_1)= \Mod(\varphi_2)$，则称$\varphi_1$和$\varphi_2$为\emph{逻辑等值公式}（简称为\emph{等值公式}），记作$\varphi_1 \equiv \varphi_2$。
值得注意的是，上述的记号也适用于讨论的对象为公式的集合的情形。
此外，给定一个公式的集合$\Pi$和一个初始$\MPK$-结构$\cal K$，若对于$\Pi$中的任意一个公式$\varphi$都有${\cal K} \models \varphi$，则${\cal K} \models \Pi$。

对于给定的公式$\varphi$，将出现在$\varphi$中的原子命题的集合记为$\Var(\varphi)$。此外，给定公式$\varphi$和原子命题的集合$V$，如果存在一个公式$\psi$使得$\Var(\psi) \cap V = \emptyset$且$\varphi \equiv \psi$，那么说$\varphi$与$V$中的原子命题\emph{无关}，简称为\emph{$V$-无关}（ \emph{$V$-irrelevant}），写作$\IR(\varphi,V)$。
一种特殊的形式是$\Var(\varphi) \subseteq V$，此时称$\varphi$为集合$V$上的公式。
可以类似定义公式的集合与原子命题集合的无关性，也即是：如果对于公式的集合$\Pi$中的任意一个公式$\varphi$，$\IR(\varphi,V)$都成立，则$\Pi$与$V$中的原子命题无关，记为$\IR(\Pi,V)$。

\subsection{$\CTL$的标准形式}

在讲述$\CTL$的标准形式之前，先引入一种带有索引的$\CTL$，记为$\CTL_{ind}$。
这种语言是在$\CTL$的已有符号下加入下面几种符号得到：
\begin{itemize}
	\item 命题常量符号$\start$；
	\item 一个可数无限的索引集$\Ind$；
	\item 带有索引$ind$（$ind \in \Ind$）的时序算子：$\EXIST_{\tuple{ind}} \NEXT$, $\EXIST_{\tuple{ind}} \FUTURE$, $\EXIST_{\tuple{ind}} \GLOBAL$, $\EXIST_{\tuple{ind}} \UNTILL$, 和 $\EXIST_{\tuple{ind}} \UNLESS$。
\end{itemize}
与$\CTL$公式的定义类似，其公式可以递归地定义如下：
\begin{equation}\label{def:CTL_ind:formulas}
	\phi ::=  \bot \mid \top \mid p \mid\neg\phi \mid \phi\lor\phi \mid
	\EXIST \NEXT \phi \mid
	\EXIST \GLOBAL \phi \mid
	\EXIST (\phi\ \UNTILL\ \phi)\mid
	\EXIST_{ind} \NEXT \phi \mid
	\EXIST_{ind} \GLOBAL \phi \mid
	\EXIST_{ind} (\phi\ \UNTILL\ \phi)
\end{equation}

与$\CTL$不同的是，$\CTL_{ind}$的语义定义在一种扩展的初始-Kripke结构上，该结构被称为$\Ind$-Kripke结构。
一个$\Ind$-Kripke结构是一个五元组$\Hm=(S,R,L,[\_],s_0)$，且除了$[\_]$，其余元素都跟初始结构中的元素对应。该五元组中的$[\_]$是一个以$\Ind$为定义域，$2^{S\times S}$为值域的后继函数，即$[\_]:\Ind \rto 2^{S\times S}$，且满足对于任意的$s\in S$都存在唯一一个$s'\in S$使得$(s,s')\in [ind]\cap R$。
记$\pi_{s_i}^{ind}$是$\Hm$上的一条路径$(s_i,s_{i+1},s_{i+2},\dots)$，且对于任意的$j\ge i$都有：
\[
(s_j,s_{j+1}) \in [ind] \qquad 
\]
一个$\Ind$-Kripke结构$\Hm$和其上的一个状态$s$构成一个$ind$-结构，记为$(\Hm,s)$。同理，如果$s$是初始状态$s_0$，则称$(\Hm,s_0)$为初始$ind$-结构。

令$\varphi$是一个$\CTL_{ind}$公式、${\cal K}=(\Hm,s_0)$是一个初始$ind$-结构、且$s$是$\Hm$上的一个状态，则$\varphi$和$(\Hm,s_0)$的可满足关系$(\Hm,s_0)\models \varphi$被定义如下（这里只列出带有索引的公式的可满足关系，其余公式的可参加$\CTL$部分的定义）：
\begin{itemize}
	\item $({\cal M},s) \models \start$当且仅当$s=s_0$；
	\item $({\cal M},s)\models \EXIST_{\tuple{ind}} \NEXT \psi$当且仅当对于路径$\pi_{s}^{\tuple{ind}}$，有$(\Hm, s')\models \psi$且$(s, s') \in [ind]$;
	\item $({\cal M},s)\models \EXIST_{\tuple{ind}}\GLOBAL\psi$当且仅当对于任意的$s' \in  \pi_{s}^{\tuple{ind}}$，%occurring in $\pi_{s}^{\tuple{ind}}$,
	$(\Hm,s') \models \psi$;
	\item $({\cal M},s)\models \EXIST_{\tuple{ind}}(\psi_1\UNTILL\psi_2)$
	当且仅当存在路径$\pi_{s}^{\tuple{ind}} = (s=s_1, s_2, \dots)$上的状态$s_j$（$j\ge 1$），使得$(\Hm,s_j) \models \psi_2$，且对于任意的$s_k \in \pi_{s}^{\tuple{ind}}$，若$1\leq k < j$，则$(\Hm,s_k) \models \psi_1$；
	\item $(\Hm,s) \models \EXIST_{\tuple{ind}} \FUTURE \psi$当且仅当$(\Hm,s) \models \EXIST_{\tuple{ind}}(\top \UNTILL\psi)$；
	\item $({\cal M},s)\models \EXIST_{\tuple{ind}}(\varphi\UNLESS\psi)$当且仅当$(\Hm,s) \models \EXIST_{\tuple{ind}}\GLOBAL \varphi$或$({\cal M},s)\models \EXIST_{\tuple{ind}}(\varphi\UNTILL\psi)$。
\end{itemize}

对于给定的公式$\varphi$和初始$ind$-结构${\cal K}=(\Hm,s_0)$，如果${\cal K} \models \varphi$，则称${\cal K}$是$\varphi$的一个\emph{$\Ind$-模型}，也称${\cal K}$满足$\varphi$。其他的术语与$\CTL$部分的类似，这里不再赘述。

已有结果表明，任意的$\CTL$公式能够在多项式时间内被转换为$\CTL$的全局子句分离的范式（separated normal form with global clauses for \CTL，$\CTLsnf$子句）\cite{zhang2008first,zhang2014resolution}。
$\CTLsnf$子句是具有下面几种形式的公式：
\[
\begin{array}{ll}
	\ALL \GLOBAL (\start \rto \bigvee_{j=1}^{k} m_{j}) & \text{(初始句，initial clause)} \\
	\ALL \GLOBAL (\top\rto \bigvee_{j=1}^{k} m_{j}) &\text{(全局子句，global clause)} \\
	\ALL \GLOBAL (\bigwedge_{i=1}^{n} l_{i} \rto \ALL \NEXT \bigvee_{j=1}^{k} m_{j}) & (\ALL\text{-步子句，} \ALL\text{-step clause}) \\
	\ALL \GLOBAL (\bigwedge_{i=1}^{n} l_{i} \rto \EXIST_\tuple{ind} \NEXT \bigvee_{j=1}^{k} m_{j}) & (\EXIST\text{-步子句，} \EXIST\text{-step clause}) \\
	\ALL \GLOBAL (\bigwedge_{i=1}^{n} l_{i} \rto \ALL \FUTURE l) & (\ALL\text{-某时子句，} \ALL\text{-sometime clause}) \\
	\ALL \GLOBAL (\bigwedge_{i=1}^{n} l_{i} \rto \EXIST_{\tuple{ind}} \FUTURE l) & (\EXIST\text{-某时子句，} \EXIST\text{-sometime clause})\\
\end{array}
\]
其中$k$和$n$都是大于0的常量，$\start$是命题常量符号，$l_i$（$1\leq i \leq n$）、$m_j$（$1\leq j \leq k$）和$l$都是文字，且$ind \in \Ind$。
从上述标准形式中，可以看到每个$\CTLsnf$子句都是$\ALL\GLOBAL(P \rto G)$形式。因此在没有歧义的情况下，下文中将使用$P \rto G$指代这些子句。
此外，除了额外说明，本文通常讲$\CTLsnf$子句和子句统称为子句。

对于给定的公式$\varphi$（其中的$\rto$符号都用$\vee$和$\neg$表示），如果$\varphi$中所有原子命题$p$的出现都有偶数个否定符号在其之前，则称$\varphi$关于$p$是正的，否则称$\varphi$关于$p$是负的。
此外，对于给定的公式集合，如果该集合中的所有公式关于$p$都是正的，则说该集合关于$p$是正的，否则该集合关于$p$是负的。

一个$\CTL$公式$\varphi$可以通过表~\ref{tab:trans}中的规则将其转换为一个$\CTLsnf$子句的集合，记为$T_{\varphi}$。

\begin{table}[h!]%[width=.9\linewidth,cols=4,pos=h]
	%\footnotesize
	\small
	\centering\caption{转换规则}\label{tab:trans}
	\begin{tabular}{c}
		\toprule
		$
		\begin{aligned}
			& \textbf{Trans(1)}\frac{q \rto \EXIST T \varphi}{q\rto \EXIST_{\tuple{ind}} T \varphi}; \qquad
			\textbf{Trans(2)} \frac{q \rto \EXIST (\varphi_1 \UNTILL \varphi_2)}{q\rto \EXIST_{\tuple{ind}} (\varphi_1 \UNTILL \varphi_2)};
			&& 
			\textbf{Trans(3)} \frac{q\rto \varphi_1 \wedge \varphi_2}{q\rto \varphi_1, q\rto \varphi_2};\\
			&   \textbf{Trans(4)}  \frac{q\rto \varphi_1 \vee \varphi_2\ (\hbox{如果$\varphi_2$不是子句})}{ q\rto \varphi_1 \vee p, p\rto \varphi_2};
			&&\textbf{Trans(5)}  \frac{q\rto D}{\top \rto \neg q \vee D};\ \frac{q\rto \perp}{ \top \rto \neg q};\ \frac{q \rto \top}{\{\}} \\
			&  \textbf{Trans(6)} \frac{q\rto Q\NEXT \varphi\ (\hbox{如果$\varphi$不是子句})}{q\rto Q\NEXT p, p\rto \varphi}; 
			&& \textbf{Trans(7)} \frac{q\rto Q\FUTURE \varphi\ (\hbox{如果$\varphi$不是文字})}{q\rto Q\FUTURE p, p\rto \varphi}; \\
			&  \textbf{Trans(8)} \frac{q\rto Q(\varphi_1 \UNTILL \varphi_2) \  (\hbox{如果$\varphi_2$不是文字})}{q\rto Q(\varphi_1 \UNTILL p),  p\rto \varphi_2}; 
			&& \textbf{Trans(10)} \frac{q\rto Q\GLOBAL \varphi}{\ q \rto  p, p\rto \varphi,p\rto Q\NEXT p};  \\
			& \textbf{Trans(11)} \frac{q\rto Q(\varphi \UNTILL l)}{q \rto l\vee p, p\rto \varphi, p\rto Q\NEXT(l\vee p),q\rto Q \FUTURE l};
			&& \textbf{Trans(12)} \frac{q\rto Q(\varphi \UNLESS l)}{q \rto l\vee p, p\rto \varphi, p\rto Q\NEXT(l\vee p)}.
		\end{aligned}
		$\\
		\bottomrule
	\end{tabular}
\end{table}
在表~\ref{tab:trans}中，$T\in \{\NEXT, \GLOBAL, \FUTURE\}$，$ind$是规则中引入的新的索引且$Q\in \{\ALL, \EXIST_{\tuple{ind}}\}$；
$q$是一个原子命题, $l$是一个文字, $D$是文字的吸取（即子句）, $p$是新的原子命题；$\varphi$，$\varphi_1$，和$\varphi_2$都是\CTL公式。

规则\textbf{Trans(1)}和规则\textbf{Trans(2)}为每一个存在路径量词$\EXIST$引入一个新的索引$ind$；规则\textbf{Trans(3)}到规则\textbf{Trans(5)}通过引入新的替换规则将复杂的公式用新的原子命题替换；规则\textbf{Trans(6)}到规则\textbf{Trans(12)}用于移除掉那些不能出现在$\CTLsnf$中的时序操作符~\cite{DBLP:journals/aicom/ZhangHD10}。


给定一个$\CTL$公式$\varphi$，将其转换为一个$\CTLsnf$字句集合的主要步骤如下：
\begin{itemize}
	\item[] (1) 将公式$\CTL$转换为其NNF（negation normal form）\footnote{如果公式中的否定符号“$\neg$”仅出现在原子命题之前，且联结符号只有“$\vee$”和“$\wedge$”这两种，则称该公式是NNF形式的公式。}形式，记为$nnf(\varphi)$；
	\item[] (2) 使用表~\ref{tab:simp}中的等价公式化简$nnf(\varphi)$，得到$simp(nnf(\varphi))$；
	\item[] (3) 使用表~\ref{tab:trans}中的规则将$\{\ALL\GLOBAL(\start\rto z), \ALL\GLOBAL(z \rto simp(nnf(\varphi)))\}$化简为$\CTLsnf$子句的集合。
\end{itemize}

%\begin{table}[h!]
%	\centering
%	\centering\caption{化简规则。其中$Q\in \{\ALL, \EXIST\}$且$T\in \{\NEXT,\GLOBAL,\FUTURE\}$。}
%	%\newcolumntype{Y}{>{\raggedleft\arraybackslash}X}
%	\begin{tabular}{ccc}
%	%	\toprule
%		 $(\varphi \wedge \top) \rto \varphi$;
%		& $(\varphi \wedge \bot) \rto \bot$;
%		& $(\varphi \vee \top) \rto \top$;\\
%		 $(\varphi \vee \bot) \rto \varphi$; 
%		& $\neg \top \rto \bot$; 
%		& $\neg \bot \rto \top$; \\
%		 $QT \bot \rto \bot$; 
%		& $QT \top \rto \top$;  
%		& $Q(\varphi \UNTILL \bot) \rto \bot$;\\
%		 $Q(\varphi \UNTILL \top) \rto \top$;
%		& $Q(\bot \UNTILL \varphi) \rto \varphi$;
%		& $Q(\top \UNTILL \varphi) \rto Q\FUTURE \varphi$;\\
%		 $Q(\varphi \UNLESS \bot) \rto Q\GLOBAL \varphi$;
%		& $Q(\varphi \UNLESS \top) \rto \top$; 
%		& $Q(\bot \UNLESS \varphi) \rto \varphi$;\\
%		 $Q(\top \UNLESS \varphi) \rto \top$.
%%	\bottomrule
%	\end{tabular}\label{tab:simp}
%	%\caption{This is an example table}
%\end{table}

\begin{table}[h!]%[width=.9\linewidth,cols=4,pos=h]
%	\footnotesize
	\centering\caption{化简规则。其中$Q\in \{\ALL, \EXIST\}$且$T\in \{\NEXT,\GLOBAL,\FUTURE\}$。}\label{tab:simp}
	\begin{tabular}{c}
		\toprule
		$
		\begin{aligned}
						& (\varphi \wedge \top) \rto \varphi;
						&&	(\varphi \wedge \bot) \rto \bot;
						&&  (\varphi \vee \top) \rto \top;\\
						& (\varphi \vee \bot) \rto \varphi; 
						&&  \neg \top \rto \bot; 
						&& \neg \bot \rto \top; \\
						&  QT \bot \rto \bot; 
						&& QT \top \rto \top;  
						&& Q(\varphi \UNTILL \bot) \rto \bot;\\
						& Q(\varphi \UNTILL \top) \rto \top;
						&& Q(\bot \UNTILL \varphi) \rto \varphi;
						&& Q(\top \UNTILL \varphi) \rto Q\FUTURE \varphi;\\
						& Q(\varphi \UNLESS \bot) \rto Q\GLOBAL \varphi;
						&& Q(\varphi \UNLESS \top) \rto \top; 
						&& Q(\bot \UNLESS \varphi) \rto \varphi;\\
						& Q(\top \UNLESS \varphi) \rto \top.
		\end{aligned}
		$\\
		\bottomrule
	\end{tabular}
\end{table}

下面通过一个简单的例子~\cite{zhang2014resolution}来展示上述转换步骤：
\begin{example}\label{exmp:transbot}
	令$\varphi=\neg \ALL \FUTURE p \wedge \ALL\FUTURE(p \wedge \top)$，下面给出将$\varphi$转换为$\CTLsnf$的详细步骤。
	(1) 将公式$\varphi$转换为其NNF形式：$\EXIST\GLOBAL \neg p \wedge \ALL\FUTURE(p \wedge \top)$；
	
	(2) 化简(1)中的公式为：$\EXIST\GLOBAL \neg p \wedge \ALL\FUTURE p$；
	
	(3) 使用表~\ref{tab:trans}中的规则转化$\{\ALL\GLOBAL(\start \rto z), \ALL\GLOBAL(z \rto (\EXIST\GLOBAL \neg p \wedge \ALL\FUTURE p))\}$，详细步骤如下：
	\begin{align*}
		&1.\ \start \rto z && \\
		&2.\ z \rto \EXIST\GLOBAL \neg p \wedge \ALL\FUTURE p &&  \\
		% \end{align*}
		% \begin{align*}
		&3.\ z \rto  \EXIST\GLOBAL \neg p && (2, \textbf{Trans(3)})\\
		&4.\ z \rto \ALL\FUTURE p && (2, \textbf{Trans(3)})\\
		&5.\ z \rto  \EXIST_{\tuple{1}}\GLOBAL \neg p  && (3, \textbf{Trans(1)})\\
		&6.\ z \rto x && (5, \textbf{Trans(10)})\\
		&7.\ x\rto \neg l && (5, \textbf{Trans(10)})\\
		&8.\ x\rto \EXIST_{\tuple{1}} \GLOBAL x&& (5, \textbf{Trans(10)})\\
		&9.\ \top \rto \neg z \vee x && (6, \textbf{Trans(5)}) \\
		% \end{align*}
		% \begin{align*}
		&10.\ \top \rto \neg x \vee \neg p && (7, \textbf{Trans(5)}) 
	\end{align*}

因此，得到的$\varphi$对应的$\CTLsnf$公式为：
\begin{align*}
	&1.\ \start \rto z && 2.\ z \rto \ALL\FUTURE p && 3.\ x\rto \EXIST_{\tuple{1}} \GLOBAL x\\
	&4.\ \top \rto \neg z \vee x && 5.\ \top \rto \neg x \vee \neg p.
\end{align*}
\end{example}






\subsection{$\mu$-演算}
$\mu$-演算是一种表达能力与S2S\footnote{无限完全二叉树下的一元二阶理论（monadic second order theory of the infinite complete binary tree），简称为S2S。}相同的逻辑语言，LTL（线性时序逻辑，linear temporal logic）、CLT和CTL$^*$能表达的属性都能用$\mu$-演算来表示。
$\mu$-演算是模态逻辑的扩展，本文讨论Kozen提出的命题$\mu$-演算~\cite{DBLP:journals/cacm/Kozen83}。构成$\mu$-演算语言的符号有：
\begin{itemize}
	\item 原子命题符号的集合：$\cal A$；
	\item 变元符号的可数集：$\cal V$；
	\item 常量符号：$\bot$和$\top$；
	\item 布尔联结符号：$\vee$，$\wedge$，和$\neg$;
	\item 路径量词符号：$\ALL$和$\EXIST$;
	\item 时序操作符号：\NEXT\ 用于用于表示“下一个状态”;
	\item 不动点符号：$\mu$和$\nu$，分别表示“最小不动点”和“最大不动点”。
\end{itemize}

通常认为$\ALL\NEXT$和$\EXIST\NEXT$的优先级比布尔连接符高~\cite{bradfield2018mu}，为了保证文章的统一性，本文规定各类符号之间的如下优先级：
\[
\neg\qquad \EXIST\NEXT\qquad \ALL\NEXT\qquad \wedge\qquad \vee\qquad \mu\qquad \nu.
\]
此时可如下定义$\mu$-演算的公式：
\[
\varphi := \top \mid \bot \mid p\mid \neg p\mid  X\mid \varphi \vee \varphi \mid \varphi \wedge \varphi \mid \EXIST\NEXT \varphi\mid \ALL\NEXT \varphi \mid \mu X. \varphi\mid \nu X. \varphi
\]
其中$p\in \Ha$且$X\in {\cal V}$。称出现在$\mu X. \varphi$和$\nu X. \varphi$中的变元$X$是\emph{受约束的}（bound），不受约束的变元称为\emph{自由变元}。
原子命题和变元符号及其各自的否定称为\emph{文字}，出现在公式$\varphi$中的原子命题的集合记为$\Var(\varphi)$。

由上述定义可以看出，“$\neg$”符号只能出现在原子命题符号的前面。但在$\mu$-演算公式的一般定义中，“$\neg$”符号可以出现在变元符号的前面，但是要求变元符号前的“$\neg$”符号的个数为偶数。尽管如此，这两种方式定义的公式具有相同的表达能力。

对于给定的公式$\varphi$，若出现在其中的自由变元与受约束变元不同，且每个变元最多被约束一次，则称公式$\varphi$是\emph{取名恰当的}（well-named）。此外，若公式$\delta X.\varphi(X)$（$\delta \in \{\mu, \nu\}$）中变元$X$的每次出现都是在$\EXIST\NEXT$或$\ALL\NEXT$的辖域\footnote{给定公式$*\varphi$（$*\in \{\neg, \EXIST\NEXT,\ALL\NEXT, \mu X, \nu X\}$），则称$\varphi$为$*$在公式$*\varphi$中的\textbf{辖域}。对于公式$\varphi * \psi$（$*\in \{\vee, \wedge\}$），则分别称$\varphi$和$\psi$为他们之间的$*$在$\varphi * \psi$中的左辖域和右辖域。}内，则称变元在公式$\delta X.\varphi(X)$中是\emph{受保护的}（guarded）。
一个没有自由变元出现的公式称为\emph{$\mu$-句子}（sentence）。在本文中所谈到的公式指的是取名恰当的、受保护的$\mu$-句子。

与$\CTL$公式类似，$\mu$-演算公式（简称为$\mu$-公式或公式）的语义定义在Kripke结构上。但是，与$\CTL$不同的是，这里不要求$\Hm=(S,R,L,r)$中的$r$为初始状态，且这里的$r$称为\emph{根}（root）。
\begin{definition}
	给定$\mu$-演算公式$\varphi$、初始结构$\Hm$和一个赋值函数$v: {\cal V} \rto 2^S$。公式在$\Hm$和$v$上的解释是$S$的一个子集$\left\| \varphi\right\|_v^{\Hm}$（当$\Hm$在上下文中是显然的，则可以省去上标）：
	\begin{align*}
		& \left \| p\right \|_v = \{s\mid p \in L(s)\} \ ,\ \left\|\top\right\|_v = S \ ,\ \left\|\bot\right\|_v = \emptyset, \\
		& \left\|\neg p\right\|_v = S- \left\| p\right\|_v,\\
		& \left\| X\right\|_v = v(X),\\
		& \left\|\varphi_1 \vee \varphi_2\right\|_v = \left\|\varphi_1\right\|_v \cup \left\|\varphi_2\right\|_v,\\
		& \left\|\varphi_1 \wedge \varphi_2\right\|_v = \left\|\varphi_1\right\|_v \cap \left\|\varphi_2\right\|_v,\\
		& \left\|\EXIST \NEXT \varphi\right\|_v = \{s\mid \exists s'. (s, s') \in R \wedge s' \in \left\|\varphi\right\|_v\},\\
		& \left\|\ALL \NEXT \varphi\right\|_v = \{s\mid \forall s'. (s, s') \in R \Rto s' \in \left\|\varphi\right\|_v\},\\
		& \left\| \mu X. \varphi\right\|_v = \bigcap\{S' \subseteq S \mid \left\|\varphi\right\|_{v[X:= S']} \subseteq S'\},\\
		& \left\| \nu X. \varphi\right\|_v = \bigcup\{S' \subseteq S \mid S' \subseteq \left\|\varphi\right\|_{v[X:= S']}\}.
	\end{align*}
其中，$v[X:= S']$是一个赋值函数，它除了$v[X:= S'](X)=S'$之外，和$v$完全相同。也即是，对任意的$Y\in {\cal V}$：
\[v[X:= S'](Y) =
\left\{
\begin{array}{ll}
	S'\hbox{，} \ \ \qquad \qquad \qquad \hbox{若$Y = X$；} \\
	v(Y)\hbox{，} \ \ \ \qquad \qquad \ \ \hbox{否则。}
\end{array}
\right.
\]
\end{definition}

在下文中，若$s\in \left\| \varphi \right\|_v$，则称$s$“满足”$\varphi$，记为$(\Hm, s, v) \models \varphi$。
此时，若$(\Hm, r, v) \models \varphi$，则称$(\Hm, r, v)$为$\varphi$的一个模型。
当公式$\varphi$为$\mu$-句子时，可以将赋值函数$v$省略，记为$(\Hm, s) \models \varphi$。
记$\Mod(\varphi)$为$\varphi$的模型的集合。其他记号与$\CTL$情形类似，这里不再赘述。

\subsection{$\mu$-公式的析取范式}
Janin等人首先提出了$\mu$-演算的析取范式~\cite{janin1995automata}，后来被逐步完善，本文使用文章~\cite{d2006modal}中的析取$\mu$-公式的定义。

在给出该定义之前，事先给出$\mu$-公式的另一种定义，称为\emph{覆盖-语法}（cover-syntax）。该定义是将上述$\mu$-公式的定义中的$\EXIST\NEXT$用\emph{覆盖操作}（cover operator）的集合来替换得到。在覆盖-语法中，
\begin{itemize}
	\item $Cover(\emptyset)$；
	\item 对任意的$n\geq 1$，若$\varphi_1,\dots, \varphi_n$是公式，则$Cover(\varphi_1, \dots, \varphi_n)$是公式。
\end{itemize}
对于给定的初始结构$\Hm=(S,R,L,r)$和赋值函数$v$：
\begin{itemize}
	\item $(\Hm,r,v) \models Cover(\emptyset)$当且仅当$r$没有任何的后继状态；
	\item $(\Hm, s,v ) \models Cover(\varphi_1, \dots, \varphi_n)$当且仅当
	\begin{itemize}
		\item 对任意的$i = 1, . . . , n$，存在$(s, t) \in R$使得$(\Hm, t,v) \models \varphi_i$;
		\item 对任意的$(s, t) \in R$，存在$i\in \{1, . . . , n\}$使得$(\Hm, t,v) \models \varphi_i$。
	\end{itemize}
\end{itemize}

尽管覆盖-语法在形式上与上一小节中$\mu$-公式的定义大相径庭，但是已经证明这两种定义是等价的\cite{d2006modal}。
基于此，可以给出析取$\mu$-公式的形式定义如下：
\begin{definition}[析取$\mu$-公式~\cite{d2006modal}]
	析取$\mu$-公式的集合${\cal F}_d$是包含$\top$、$\bot$和不矛盾的文字的合取且封闭于下面几条规则的最小集合:
	\begin{itemize}
		\item[(1)] 吸取式（disjunctions）：若$\alpha, \beta \in {\cal F}_d$，则$\alpha \vee \beta \in {\cal F}_d$；
		\item[(2)] 特殊合取式（special conjunctions）：若$\varphi_1, \dots, \varphi_n\in {\cal F}_d$且$\delta$为不矛盾的文字的合取，则$\delta \wedge Cover(\varphi_1, \dots, \varphi_n) \in {\cal F}_d$；
		\item[(3)] 固定点操作（fixpoint operators）：若$\varphi\in  {\cal F}_d$，且对任意的公式$\psi$，$\varphi$不含有形如$X \wedge \psi$的子公式，则$\mu X. \varphi$和$\nu X. \varphi$都在 ${\cal F}_d$中。
	\end{itemize}	
\end{definition}

\section{$\CTL$下的归结}

\emph{归结}是一种用于判定给定的命题公式（或一阶公式）是否可满足的规则，该技术可以追溯到1960年Davis等的工作~\cite{DBLP:journals/jacm/DavisP60}，之后被Robinson加以完善~\cite{DBLP:journals/jacm/Robinson65}。对于给定的公式，归结给出一个反驳定理证明过程。
%除了公式的可满足性证明，归结还被用于计算命题逻辑里的遗忘。

在看见了归结在在命题逻辑和一阶逻辑中取得成就之后，科研工作者们开始将精力致力于其他非经典逻辑中，并取得了相当显著的理论成果，如：模态逻辑（K系统，Q系统，T系统，S4和S5系统）中的归结~\cite{DBLP:journals/tcs/EnjalbertC89}和时态逻辑（尤其是线性时序逻辑（LTL）和\CTL）中的归结~\cite{DBLP:conf/cade/CavalliC84,DBLP:journals/jetai/BolotovF99}。

这里主要介绍与本文直接相关的$\CTL$下的归结。$\CTL$下的归结起源于BolotovF的研究\cite{DBLP:journals/jetai/BolotovF99}，之后被Zhang等人完善~\cite{zhang2014resolution}。不论是在BolotovF的工作还是在Zhang等人的工作中，其关键点都是将$\CTL$公式转换为一个$\CTLsnf$子句的集合。本文使用Zhang等人在~\cite{zhang2014resolution}中的规则，如表所示。

\begin{table}[tb]%[width=.9\linewidth,cols=4,pos=h]
	%\footnotesize
	\small
	\centering
	\caption{归结规则}\label{tab:res}
	\begin{tabular}{l}
		\toprule
		$
		\begin{aligned}
			& \textbf{(SRES1)}\frac{P\rto \ALL\NEXT(C\vee l), Q\rto \ALL\NEXT(D\vee \neg l)}{P\wedge Q \rto \ALL\NEXT(C\vee D)};
			&& \textbf{(SRES2)} \frac{P\rto \EXIST_{\tuple{ind}} \NEXT(C\vee l), Q\rto \ALL\NEXT(D\vee \neg l)}{P\wedge Q \rto \EXIST_{\tuple{ind}}\NEXT(C\vee D)};\\
			& \textbf{(SRES3)} \frac{P\rto \EXIST_{\tuple{ind}}\NEXT(C\vee l), Q \rto \EXIST_{\tuple{ind}}\NEXT(D\vee \neg l)}{P\wedge Q\rto\EXIST_{\tuple{ind}}\NEXT(C\vee D)};  
			&&   \textbf{(SRES4)} \frac{\start \rto C\vee l, \start \rto D \vee \neg l}{\start \rto C\vee D}; \\
			& \textbf{(SRES5)} \frac{\top \rto C\vee l, \start \rto D \vee \neg l}{\start \rto C \vee D};
			&&  \textbf{(SRES6)} \frac{\top \rto C \vee l, Q \rto \ALL\NEXT(D \vee \neg l)}{Q\rto \ALL \NEXT(C\vee D)}; \\
			& \textbf{(SRES7)} \frac{\top \rto C \vee l, Q \rto \EXIST_{\tuple{ind}} \NEXT(D \vee \neg l)}{Q\rto \EXIST_{\tuple{ind}}\NEXT(C\vee D)}; 
			&&  \textbf{(SRES8)} \frac{\top \rto C\vee l, \top \rto D \vee \neg l}{\top \rto C \vee D};\\
			& \textbf{(RW1)} \frac{\bigwedge_{i=1}^n m_i \rto \ALL\NEXT \perp}{\top \rto \bigvee_{i=1}^n \neg m}; 
			&& \textbf{(RW2)} \frac{\bigwedge_{i=1}^n m_i \rto \EXIST_{\tuple{ind}}\NEXT \perp}{\top \rto \bigvee_{i=1}^n \neg m}; \\
			& \textbf{(ERES1)} \frac{\Lambda \rto \EXIST \NEXT \EXIST\GLOBAL l, Q \rto \ALL \FUTURE \neg l}{Q \rto \ALL(\neg \Lambda \UNLESS \neg l)};
			&& \textbf{(ERES2)} \frac{\Lambda \rto \EXIST_{\tuple{ind}} \NEXT \EXIST_{\tuple{ind}}\GLOBAL l, Q \rto \EXIST_{\tuple{ind}} \FUTURE \neg l}{Q \rto \EXIST_{\tuple{ind}}(\neg \Lambda \UNLESS \neg l)}.
		\end{aligned}
		$\\
		\bottomrule
	\end{tabular}
\end{table}
在表~\ref{tab:res}中$P$和$Q$是文字的合取，$C$和$D$是文字的吸取，$l$是一个文字。此外，$\Lambda=\bigvee_{i=1}^n \bigwedge_{i=1}^{m_i}P_j^i$和$P_j^i$是文字的吸取，且$1\leq i\leq n$和$1\leq j\leq m$。

规则$\textbf{SRES1-8}$被叫做\emph{步-归结规则}（step resolution rule）、$\textbf{RW1-2}$被叫做\emph{重写规则}（rewrite rule）、$\textbf{ERES1-2}$被叫做\emph{可能归结规则}（eventuality resolution rule）。
值得注意的是，规则 $\textbf{ERES1}$ 的前提“$\Lambda \rto \EXIST \NEXT \EXIST\GLOBAL l$”表示如下子句的集合$\Lambda_{\EXIST\GLOBAL}$：
\begin{align*}
	& P_1^1\rto *C_1^1, & & & P_1^n\rto *C_1^n,\\
	& \vdots & && \vdots\\
	& P_{m_1}^1 \rto * C_{m_1}^1, & \ldots && P_{m_n}^n\rto *C_{m_n}^n,
\end{align*}
其中，对任意的$i~(1\le i\le n)$，
\begin{itemize}
	\item 存在一个索引$ind \in {\cal I}$ 使得 $*$ 要么为空符号，要么为 $\{\ALL\NEXT, \EXIST_{\tuple{ind}}\NEXT\}$中的一个，
	\item $\left(\bigwedge_{j=1}^{m_i} C_j^i\right) \rto l$成立，且
	\item $\left(\bigwedge_{j=1}^{m_i} C_j^i\right) \rto \left(\bigvee_{i=1}^n\bigwedge_{j=1}^{m_i} P_j^i\right)$成立。
\end{itemize}

上面的最后两个条件确保了子句集合$\Lambda_{\EXIST\GLOBAL}$能够蕴涵$\Lambda \rto \EXIST \NEXT \EXIST\GLOBAL l$。规则$\textbf{ERES2}$的第一个前提与$\textbf{ERES1}$的类似。$\textbf{ERES1}$的结果能通过表~\ref{tab:trans}中的转换规则转换成等价可满足的全局和$\ALL$-步子句的集合，$\textbf{ERES2}$的结果则通过表~\ref{tab:trans}中的规则转换成等价可满足的全局和$\EXIST$-步子句的集合。值得注意的是在转换$\textbf{ERES1-2}$的结果为子句集合的过程中会引入一个新的原子命题~\cite{zhang2014resolution}。
从这个角度来看，每个归结规则的前件和结果都是子句形式。

对于给定的$\CTL$公式，使用上述的归结规则可以到处一个子句的集合。
形式化地说，源于$\CTLsnf$子句集合$S$的一个\emph{推导}（derivation）是一个满足如下条件的$\CTLsnf$子句集合的序列$S_0, S_1, S_2, \ldots, $：
\begin{itemize}
	\item $S_0=S$，和
	\item $S_{i+1} = S_i\cup \{\alpha\}~(i\ge 0)$，其中$\alpha\notin S_i$是对$S_i$的某些子句使用一条归结规则得到的结果。
\end{itemize}

$\CTLsnf$子句集合$S$的一个\emph{反驳}是一个源于$S$的推导$S_0, S_1, S_2, \ldots, S_i$，且$S_i$（$i\geq 0$）中包含一个矛盾——公式$\top\rto\bot$ 或 $\start\rto\bot$。

为了判定$\CTL$公式$\varphi$的可满足性，基于归结的判定过程用于检查$T_{\varphi}$是否有反驳存在。定理 5.6、5.30和6.1~\cite{zhang2014resolution}已经证明这一过程是可靠和完备的。因而，下面的推论显然成立。
\begin{corollary}
	给定两个$\CTL$公式$\varphi$和$\psi$。 则$\varphi\models\psi$ 当且仅当当且仅当 $T_{\varphi\land\neg\psi}$有一个反驳。
\end{corollary}

\begin{example}[例~\ref{exmp:transbot}的扩展]\label{exmp:resbot}
	对例~\ref{exmp:transbot}中的子句使用表~\ref{tab:res}中的归结规则，得到如下子句：
	\begin{align*}
		&(1)\ \start \rto x  && (1, 4, \textbf{SRES5})\\
		&(2)\ w \rto \ALL\NEXT (p \vee \neg x) && (2, 3,5,\textbf{ERES1})\\
		&(3)\ \top \rto  \neg z \vee p \vee \neg x  && (2, 3,5,\textbf{ERES1})\\
		&(4)\ \top \rto \neg z \vee l \vee w && (2, 3,5,\textbf{ERES1})\\
		&(5)\ w \rto \ALL \NEXT(x \vee w) && (2, 3,5,\textbf{ERES1})\\
		&(6)\ \top \rto \neg z \vee \neg x && (5, (3), \textbf{SRES8})\\
		&(7)\ \start \rto \neg x && (1, (6), \textbf{SRES5}) \\
		% \end{align*}
		% \begin{align*}
		&(8)\ \start \rto \bot && ((1), (7), \textbf{SRES4}).
	\end{align*}
	由于在这一推导中有一个子句集合包含一个矛盾，即：$\start \rto \bot$，所以$T_{\varphi}$存在一个反驳。因此，$\varphi$是不可满足的。
\end{example}


\section{遗忘理论基础和SNC（WSC）}
这部分主要介绍遗忘理在经典逻辑和模态逻辑S5下的定义，以及基于遗忘的SNC（WSC）的计算方法。
\subsection{经典逻辑下的遗忘}\label{chapter:sub:proforgetting}
遗忘一词起源于经典逻辑（包括命题逻辑和一阶逻辑）~\cite{lin1994forget}，给定一个命题公式$\varphi$和一个原子命题$p$，下面将介绍一下在$\varphi$中遗忘（forget）掉$p$。
在\ref{chapter01:forgetting}中，从$\varphi$中遗忘掉$p$ 得到的结果为$\Forget(\varphi, \{p\}) \equiv \varphi[p/\top] \vee \varphi[p/\bot]$。


\begin{example}\label{exmp:fish}
	某学校有$a$和$b$两个食堂，学生要么去$a$食堂吃饭要么去$b$食堂吃饭，如果想吃烤鱼（fish，$f$）就去$a$食堂吃饭，如果想吃炒饭（rice，$r$）就去$b$食堂吃饭。这一知识可表示为命题公式$\varphi=(a \vee b) \wedge (f\rto a) \wedge (r \rto b)$。如果此时不考虑鱼，即：由于某种原因$a$食堂就不在卖烤鱼了，此时就应该“遗忘”烤鱼。这一计算过程表示如下：
	\begin{align*}
		\Forget(\varphi, \{f\}) & \equiv \varphi[f/\top] \vee \varphi[f/\bot] \\
		& \equiv [(a \vee b) \wedge (\top \rto a) \wedge (r \rto b)] \vee  [(a \vee b) \wedge (\bot \rto a) \wedge (r \rto b)]\\
		& \equiv [(a \vee b) \wedge a \wedge (r \rto b)] \vee  [(a \vee b) \wedge (r \rto b)]\\
		& \equiv (a \vee b) \wedge (r \rto b).
	\end{align*}
\end{example}

直观上来看，这个结果应该比原始的公式$\varphi$还要弱，但是能够蕴含同样的任何不包含$f$的句子（sentence），也就是说遗忘只能影响与$f$相关的语义。
这一性质可由互模拟这一词来表示。对于解释之间的互模拟来说，对于原子命题$p$，如果对任意的$q\in \Ha-\{p\}$有$q \in I_1$当且仅当$q \in I_2$，则称解释$I_1$与$I_2$是$p$互模拟的，记为：$I_1 \sim_{p} I_2$。


在一阶逻辑中，一阶逻辑语言${\cal L}_f$的解释有两种：${\cal L}_f$和结构有联系或没有联系，互模拟的定义就要困难一些。这里考虑和结构有联系的情形，一个\emph{一阶结构}由论域（domain）、指定的个体、关系和函数构成。此时，${\cal L}_f$中的个体符合、$n$-元关系符号和$m$-元函数符号分别被解释为这个结构中指定的论域中的个体、论域上的$n$-元关系和$m$-元全函数（即处处有定义的函数）。对于给定的一阶结构$M$和$X\in \{\hbox{元组，关系符号，函数符号}\}$，$M[X]$表示结构$M$对$X$的解释，且$M[(a_1, a_2, \dots, a_i)]$ = $(M[a_1],$ $M[a_2], \dots, M[a_i])$。

给定实例化（ground atom）原子$P(\vec{t})$（$\vec{t}$是一个$n$元组）、$M_1$和$M_2$为一阶结构（论域（domain）、指定的个体、关系和函数构成一个一阶结构），则$M_1 \sim_{P(\vec{t})} M_2$ 当且仅当除了$P(\vec{t})$的真值$M_1$和$M_2$相同，即：
\begin{itemize}
	\item[(i)] $M_1$和$M_2$有相同的论域，且每个函数符号被解释成相同的函数；
	\item[(ii)] 对于和$P$不同的任意关系符号$Q$，$M_1[Q]=M_2[Q]$;
	\item[(iii)] 令$\vec{u} = M_1[\vec{t}]$，则对于该论域中任意与$\vec{u}$不同的元组$\vec{d}$，$\vec{d} \in M_1[P]$ 当且仅当$\vec{d} \in M_2[P]$。
\end{itemize}

现在给出如下一阶逻辑中遗忘实例化原子的形式化定义：
\begin{definition}[定义 1~\cite{lin1994forget}]\label{def:fol_fogetting}
	给定一个句子（sentence）$\varphi$和实例化原子$p$，$\varphi'$是从$\varphi$中遗忘掉$p$的结果当且仅当对任意的结构$M$，$M$是$\varphi'$的模型当且仅当存在一个$\varphi$的模型$M'$使得$M \sim_p M'$。
\end{definition}

从句子$\varphi$中遗忘掉实例化原子$P(\vec{t})$比命题逻辑下的遗忘多了一步，即事先将$\varphi$中的所有$P(\vec{t'})$的出现用$(\vec{t
} = \vec{t'}\wedge P(\vec{t})) \vee (\vec{t} \not= \vec{t'}\wedge P(\vec{t'}))$来替换，这一结果记为$\varphi[P(\vec{t})]$。

\begin{example}
	令$\varphi=J(mo) \vee J(fa) \vee B(sm)$、$p = J(mo)$，则：
	\begin{align*}
		\varphi[p] & = (mo = mo \wedge J(mo)) \vee (mo \not = mo \wedge J(mo)) \vee \\
		& (mo = fa \wedge J(mo)) \vee (mo \not = fa \wedge J(fa)) \vee B(sm).
	\end{align*}
%	$$\varphi[p] = (mo = mo \wedge J(mo)) \vee (mo \not = mo \wedge J(mo)) \vee (mo = fa \wedge J(mo)) \vee (mo \not = fa \wedge J(fa)) \vee B(sm)$$
	\begin{align*}
		\Forget(\varphi, p) & = \varphi[p][p/\top] \vee \varphi[p][p/\bot]\\
		& =  (mo = mo \wedge \top) \vee (mo \not = mo \wedge \top) \vee  (mo = fa \wedge \top) \vee (mo \not = fa \wedge J(fa)) \vee B(sm) \\
		&\vee (mo = mo \wedge \bot) \vee (mo \not = mo \wedge \bot) \vee  (mo = fa \wedge \bot) \vee (mo \not = fa \wedge J(fa)) \vee B(sm)\\
		& = (mo = mo )\vee (mo \not = mo) \vee  (mo = fa ) \vee  (mo \not = fa \wedge J(fa)) \vee B(sm).
	\end{align*}
\end{example}

然而，遗忘掉一整个关系（谓词）而不是其实例得到的结果是一个二阶公式，且结构间在谓词上的互模拟与上述在实例上的有所不同：对于谓词$P$和结构$M_1$、$M_2$，$M_1 \sim_{P} M_2$ 当且仅当：
\begin{itemize}
	\item[(i)] $M_1$和$M_2$有相同的论域，且每个函数符号被解释成相同的函数；
	\item[(ii)] 对于和$P$不同的任意关系符号$Q$，$M_1[Q]=M_2[Q]$。
	%\item[(iii)] 令$\vec{u} = M_1[\vec{t}]$，则对于该论域中任意与$\vec{u}$不同的元组$\vec{d}$，$\vec{d} \in M_1[P]$ 当且仅当$\vec{d} \in M_2[P]$。
\end{itemize}
也即是排除了实例情形下的第三个条件，因为此时考虑的是整个谓词。而遗忘掉谓词的定义与遗忘掉实例的定义类似，知识将$M \sim_p M'$变为$M \sim_P M'$。

由定理~8~\cite{lin1994forget}可知，从句子$\varphi$中遗忘掉谓词$P$的结果为$\Forget(\varphi, P) = (\exists R) \varphi[P/R]$，其中$P$是$n$-元谓词，$R$是$n$-元谓词变量。
正如前面所说的，一阶逻辑下的遗忘不是封闭的，此时不一定能找到一个与$(\exists R) \varphi[P/R]$等价的一阶公式。


本文采用了基于归结的方法来计算$\CTL$中的遗忘，因此这里给出命题逻辑下基于归结的遗忘定义~\cite{DBLP:conf/kr/Delgrande14}。

\begin{definition}\label{def:resforgetting}
	给定命题公式$\varphi$和原子命题$p$，
	$$\Forget(\varphi, p) = \{C\in CNF(\varphi)\mid \hbox{ $p$ 不出现在$C$中 }\} \cup Res(CNF(\varphi), p)$$
	其中 $CNF(\varphi)$表示形成$\varphi$的合取范式的子句构成的集合，$Res(S, p)=\{C_1 \vee C_2 \mid C_1 \vee p , C_2 \vee \neg p \in S\}$。
\end{definition}

从定义\ref{def:resforgetting}不难看出计算从$\varphi$中遗忘$p$的结果可以分为三个步骤：（1）计算$\varphi$的合取范式，并得到$CNF(\varphi)$；（2）计算$Res(CNF(\varphi), p)$；（3）去除$CNF(\varphi)$包含$p$的子句。
遗忘的定义种类很多，本文的定义采用的是上述所说的互模拟方式，因此这里不再赘述其他定义，感兴趣的读者可以参考Eiter的文章~\cite{eiter2019brief}。

在描述逻辑中，如果遗忘的结果是可以用当前讨论的描述逻辑来表示的，则该结果就是一个均匀插值。而判定均匀插值的存在性通常是很费时的，如：在${\cal ALC}$ 和${\cal EL}$中是双指数时间的。因此，不难看出描述逻辑中的遗忘通常也是很困难的，尽管如此也有很多方法克服这些问题，其中扩展描述语言（如：从${\cal ALC}$到${\cal ALC}_v$~\cite{DBLP:conf/frocos/KoopmannS13}）或引入新的辅助符号~\cite{DBLP:phd/ethos/Zhao18a}是常用的方法。一些计算遗忘的工具是：基于skolem化和SOQE的SCAN~\footnote{http://www.mettel-prover.org/scan/index.html}、基于归结的Lethe~\cite{DBLP:phd/ethos/Koopmann15}和基于Ackermann引理的FAME~\cite{DBLP:conf/cade/ZhaoS18}。

\subsection{模态逻辑S5里的遗忘}\label{chapter:sub:s5forgetting}

由于时序逻辑是模态逻辑的一种，其语义是Kripke语义，这里介绍与其密切相关且基础的模态逻辑S5中的遗忘。
与经典逻辑中的遗忘相似，S5中的遗忘也是用互模拟的概念来定义。

原子命题的集合$w_1$和$w_2$是$V$-互模拟的，当且仅当$w_1 -V = w_2 -V$，记为$w_1 \sim_V w_2$，其中$w_1, w_2, V \subseteq \Ha$。
给定原子命题的集合$V\subseteq \Ha$、两个$\MPK$-解释$\Hm=\tuple{W,w}$和$\Hm'=\tuple{W,s}$，则称$\Hm$和$\Hm'$是$V$-互模拟的（记为$\Hm \lrto_{V} \Hm'$）~\cite{Zhang2008Properties}，当且仅当存在一个二元关系$\sigma \subseteq W \times W'$使得$(w,w') \in \sigma$，且：
\begin{itemize}
	\item[(i)] $\forall w_1 \in W$，$\exists w_2\in W'$使得$(w_1, w_2) \in \sigma$；
	\item[(ii)] $\forall w_2 \in W'$，$\exists w_1\in W'$使得$(w_1, w_2) \in \sigma$；
	\item[(iii)] 若$(w_1, w_2) \in \sigma$则$w_1\sim_V w_2$。
\end{itemize}

条件(i)和(ii)分别称为前向条件（forth condition）和后向条件（back condition）。需要注意的是，即使$M$和$M'$有$V$-互模拟关系，$M$和$M'$也可能有不同数量的世界个数。除此之外，从定义中不难看出，如果$\Hm \lrto_{V} \Hm'$，则有$Atom(W)-V=Atom(W' )-V$，其中$A(X)$（$X$是可能世界的集合）是由出现在$X$中的世界中的原子构成的集合。从定义中还可得出$\lrto_V$是一个等价关系。
%\subsection{描述逻辑里的遗忘}

S5关于$V$-互模拟是不变的（invariant）：如果两个$\MPK$-解释$M$和$M'$有$V$-互模拟关系，那么对于任何不包含$V$中任何原子的公式$\varphi$，$M$和$M'$同时满足或不满足公式$\varphi$。

\begin{definition}[定义 1~\cite{Zhang2008Properties}, knowledge forgetting]\label{def:s5forgetting}
	给定模态S5公司$\varphi$和$V\subseteq \Ha$。
	如果下面的等式成立，则称知识集$\KForget(\varphi,V)$是从$\varphi$遗忘掉$V$得到的结果：
	$$\Mod(\KForget(\varphi, V)) = \{\Hm' \mid \exists \Hm \in \Mod(\varphi), \Hm \lrto_V \Hm'\}.$$
\end{definition}

Zhang等人还提出了能精确描述知识遗忘的四个基本条件，给定两个公式$\varphi$和$\varphi'=\KForget(\varphi,V)$，$V\subseteq\Ha$是原子命题的集合。知识遗忘满足以下的性质：
\begin{itemize}
	\item[] (\W) 弱性质（Weaking）: $\varphi \models \varphi'$；
	\item[] (\NgP) 正向支持（Positive Persistence）：如果$\IR(\phi,V)$并且$\varphi \models \phi$，则$\varphi' \models \phi$；
	\item[] (\PP) 反向支持（Negative Persistence）：如果$\IR(\phi,V)$并且$\varphi \not \models \phi$，则$\varphi' \not \models \phi$；
	\item[] (\textbf{IR}) 无关性（Irrelevance）：$\IR(\varphi',V)$。
\end{itemize}
直观地说，(\W)和(\textbf{IR})表明“遗忘”削弱了公式$\varphi$且得到的结果与$V$无关，(\PP)和(\NgP)表明对任意与$V$无关的公式$\phi$，$\varphi \models \phi$当且仅当$\varphi' \models \phi$。总而言之，遗忘得到的结果能推出所有与$V$无关且能被$\varphi$推出的结果，且不能推出所有与$V$无关且不能被$\varphi$推出的结果。
从数据库和安全的层面讲，遗忘相当于从已有的关系表中构建出一个视图，达到了隐私保护的作用。


这四个条件与知识遗忘的关系为：
\begin{theorem}[定理 1~\cite{Zhang2008Properties}]
	%Let $\varphi$, $\varphi'$ and $\phi$ be \CTL\
	给定$\CTL$公式$\varphi$和$\varphi'$，$V \subseteq \Ha$为原子命题的集合。
	%Then t
	下面的陈述是等价的：
	\begin{itemize}
		\item[(i)] $\varphi' \equiv \CTLforget(\varphi, V)$,
		\item[(ii)] $\varphi'\equiv \{\phi \mid\varphi \models \phi \text{ and } \IR(\phi, V)\}$,
		\item[(iii)] 若$\varphi$、$\varphi'$和$V$为(i)和(ii)中提到的符号，则公设(\W)、(\PP)、(\NgP)和(\textbf{IR})成立. 
	\end{itemize}
\end{theorem}

在本文中也将说明$\CTL$和$\mu$-演算的遗忘也有上述性质。值得注意的是任意的S5公式都能转换为与之等价的\emph{模态合取范式}（MCNF）~\cite{DBLP:conf/aaai/Bienvenu07}，其字句形式为：
$$C_0 \vee \MPK C_1 \vee \dots \vee \MPK C_{n-1} \vee \MPB C_n,$$
或具有如下形式的公式的吸取——模态析取范式（MDNF）~\cite{Yongmei:IJCAI:2011,Zhang2008Properties}:
\begin{align}\label{form:s5clause}
	\varphi_0 \wedge \MPK \varphi_1 \wedge \MPB \varphi_2 \wedge \dots \wedge \MPB \varphi_n
\end{align}
其中$\varphi_i$为命题逻辑公式，$C_i$（$0\leq i \leq n$）为经典子句，且任意$\varphi_i$都可能缺失。
从子句\ref{form:s5clause}遗忘掉原子命题$p$可以转换成命题逻辑中的遗忘，即：
\begin{align*}
	&\KForget(\varphi_0 \wedge \MPK \varphi_1 \wedge \MPB \varphi_2 \wedge \dots \wedge \MPB \varphi_n)\\
	&\equiv \Forget(\varphi_0, \{p\}) \wedge \MPK(\Forget(\varphi_1, \{p\})) \wedge \bigwedge_{i=1}^{n}\MPB(\Forget(\varphi_1 \wedge \varphi_i, \{p\})).
\end{align*}
%$$ \Forget(\varphi_0, \{p\}) \wedge \MPK(\Forget(\varphi_1, \{p\})) \wedge \bigwedge_{i=1}^{n}\MPB(\Forget(\varphi_1 \wedge \varphi_i, \{p\})).$$
由此可以得出任意S5公式下的遗忘都能转换为命题逻辑中的遗忘，而命题逻辑下的遗忘已有算法和实现，这将在计算SNC和WSC部分给出。



当然，模态一阶逻辑S5中的遗忘也得到了研究~\cite{Yongmei:IJCAI:2011}，由于本文只考虑命题情形下时序逻辑的遗忘，就不再赘述。此外，Fang等人也讨论了关于多模态（multi-modal）$K_n$、 $D_n$、 $T_n$、$K45_n$、 $KD45_n$情形下的遗忘的存在性~\cite{DBLP:journals/ai/FangLD19}——这些逻辑里的遗忘总是存在的，其中$n$为智能体的个数。

\subsection{遗忘的计算方法}
在第~\ref{chapter:sub:proforgetting}和\ref{chapter:sub:s5forgetting}小节中详细介绍了经典逻辑和模态逻辑S5下遗忘的定义和一些直接的计算方法。
总的来说，这些方法分为两类：“代替”的方法和归结的方法。其中“代替”法是将要遗忘的原子命题在公式里用“$\top$”或“$\bot$”代替，归结的方法主要使用归结规则来“消除”需要遗忘的原子命题。然而，在上文中并没有对归结方法进行详细的介绍，所以这部分给出命题情形下归结方法的详细描述。%此外，计算遗忘的方法还有基于Ackermann引理的方法，本节也将详细讨论。

归结方法取决于子句的形式，子句的形式决定了归结规则的复杂性。经典命题逻辑中的子句形式比较单一，就只有一种——文字的吸取，因此归结规则就比较简单，即：
$$\frac{C_1 \vee p, C_2 \vee \neg p}{C_1 \vee C_2},$$
其中$C_1$和$C_2$是子句，$p$是原子命题。在这种情况下，基于归结的方法就如定义~\ref{def:resforgetting}那样简单。
在一阶逻辑中，将公式转换为子句形式的过程比较复杂，而归结规则也相对复杂一些。但是在一阶情形下归结，归结系统R~\cite{gabbay2008second}是可靠的且归结反驳是完备的。


在上一节中已经说明任意的S5公式能够转化成子句$C_0 \vee \MPK Ci_1 \vee \dots \vee \MPK C_{n-1} \vee \MPB C_n$的合取，因此S5下的归结系统RS5~\cite{DBLP:journals/tcs/EnjalbertC89}如下：



%归结是SOQE的基础，掌握了归结方法，

\subsection{基于遗忘的SNC（WSC）计算}
%定义、算法
SNC和WSC的定义最先由Lin提出~\cite{DBLP:journals/ai/Lin01}，这部分给出其在命题逻辑和一阶逻辑下的形式化定义和计算方法。

\begin{definition}
	令$\varphi$是一个命题公式，$V\subseteq \varphi$，$q$是一个出现在$\varphi$中但是不出现在$V$中的命题。对于$V$上的公式$\phi$，若$\varphi \models q \rto \phi$（$\varphi \models \phi \rto q$），则称公式$\phi$是$q$在$V$和$\varphi$上的必要条件（充分条件）。如果对于任意$q$在$V$和$\varphi$上的必要条件（充分条件）$\phi'$都有$\varphi \models \phi \rto \phi'$（$\varphi \models \phi' \rto \phi$），则称$\phi$是$q$在$V$和$\varphi$上的最强必要条件（最弱充分条件）。
\end{definition}

由定命题5和3~\cite{DBLP:journals/ai/Lin01}分别可知SNC和WSC是一个对偶概念，且任意公式的SNC（WSC）都能转换称原子命题的形式计算，因此这里只讨论原子命题情形下的SNC的定义及其计算。

\begin{theorem}[定理 2~\cite{DBLP:journals/ai/Lin01}]\label{chaper02:thm:SNCforgetting}
	给定命题公式$\varphi$、原子命题集合$V\subseteq \Var(\varphi)$和原子命题$q\in (\Var(\varphi)-V)$。令$V'= \Var(\varphi) - (V\cup \{q\})$，则
	\begin{itemize}
		\item $q$在$V$和$\varphi$上的SNC是$\Forget(\varphi[q/\top], V')$；
		\item $q$在$V$和$\varphi$上的WSC是$\neg \Forget(\varphi[q/\bot], V')$。
	\end{itemize}
\end{theorem}
%定义16 令T是一个命题理论，α是一个公式，P是一个出现在T∪{α}中的命题的集合。则说P的公式φ是α在P上的必要条件当且仅当T⊨α⊃φ。如果对于任意的α在P上的必要条件φ'都有T⊨φ⊃φ',则称φ是α在P上的最强必要条件。充分条件和最弱充分条件有相似的定义。


定理~\ref{chaper02:thm:SNCforgetting}表明可以用遗忘计算SNC和WSC。
基于遗忘的计算SNC（WSC）的详细算法为算法~\ref{alg:compute:pro:forgetting}，其中一个子句集合的极小集（minimal set of clauses）为满足下面性质的集合：
\begin{itemize}
	\item 所有的单元子句都被替换为true；
	\item 没有一个子句被集合中的另一个子句包蕴。其中，对于子句$C$和$C'$，若$\Var(C) \subseteq \Var(C')$，则说子句$C$包蕴$C'$。
\end{itemize}
此外，对于公式集合$S$，$S[X/Y]$为将$S$每个公式中$X$的出现全都替换成$Y$，即$S[X/Y]=\{\varphi[X/Y]\mid \varphi\in S\}$。

\begin{algorithm}[htbp]
	\small
	\setstretch{1.2}
	\caption{命题逻辑下基于遗忘的SNC计算~\cite{DBLP:journals/ai/Lin01}}
	\label{alg:compute:pro:forgetting}
	\begin{algorithmic}[1]
		\REQUIRE ~~\\
		\begin{tabular}[t]{p{8mm}l}
			$\Gamma, V, q$：& 子句集合，原子命题的集合，出现在$\Gamma$且不出现在$V$中的原子命题
		\end{tabular}
		\ENSURE ~~\\
		\begin{tabular}[t]{p{8mm}l}
			$\phi$：& $V$上的公式（$\phi$是$q$在集合$V$和$\Gamma$上的最强必要条件）
			%$SD$&:鞍点策略的支付量
		\end{tabular}
		\STATE $T_1=\{C\mid C\in \Gamma\hbox{是$V$上的一个子句}\}$，$T_2=\Gamma - T_1$
		\STATE 将出现在$T_2$中的$q$用$\top$代替，并将得到的结果和$T_1$分别转换成为子句集合的极小集$T_3$和$T_0$.
		\STATE 令$V'=\Var(T_3) - V$; 
		%\STATE 若$V' =\emptyset$，则跳转到post-processing，否则令$V'=$
		\IF{$V' =\emptyset$}
		\STATE 跳转到 post-processing;
		\ENDIF
		\STATE 从$V'$中随机选择一个原子$p$，且令$V'=V' -\{p\}$;
		\STATE 将$T_3[p/\top] \cup T_3[p/\bot]$转换为极小集得到结果$T_3$，跳转到4；
		\STATE post-processing：根据下面步骤化简$T_3$：
		\STATE \qquad 移除$T_3$中被$T_0$包蕴的子句；
		\STATE \qquad 对$T_3$中的每个子句$\alpha$，将$(T_3-\{\alpha\}) \cup T_0$转换为极小子句集$T_{\alpha}$；
		\STATE \qquad 如果$\alpha$被$T_{\alpha}$中的某个子句包蕴，则将$\alpha$从$T_3$中删除；
		\RETURN 返回$T_3$中子句的合取
	\end{algorithmic}
\end{algorithm}

在一阶逻辑中，SNC和WSC的定义和命题逻辑下相似，且也可




\section{本章小结}
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
围绕本文的研究工作，本章首先介绍了隐私以及隐私泄露的定义，明确了本文中隐私保护的研究范畴，随后，介绍了差分隐私模型并给出标准形式的定义。其次，介绍了本文研究需要的Shannon信息论知识，包括基本通信模型、信息熵、条件熵、联合熵、互信息量等概念。在此基础上，对信息论中两个重要的不等式和率失真理论进行了简要的叙述。进一步，介绍了本文将使用的优化理论知识以及在对策博弈模型中的应用。最后，结合本章内容，给定了本文中所研究的差分隐私均衡优化的定义。针对差分隐私模型中隐私保护与数据可用性之间的矛盾问题，利用均衡优化思想研究差分隐私最优化机制是本文研究的核心。本章中所介绍内容为后续章节提供了基本模型与定义，是开展后续研究工作的理论出发点。
